diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/call.c l2tpd.20051227/call.c
--- l2tpd.orig/call.c	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/call.c	2005-12-27 16:52:30.000000000 +0800
@@ -29,650 +29,612 @@
 #include <sys/ioctl.h>
 #endif
 
-struct buffer *new_payload (struct sockaddr_in peer)
+struct buffer *new_payload(struct sockaddr_in peer)
 {
-    struct buffer *tmp = new_buf (MAX_RECV_SIZE);
-    if (!tmp)
-        return NULL;
-    tmp->peer = peer;
-    tmp->start += sizeof (struct payload_hdr);
-    tmp->len = 0;
-    return tmp;
+	struct buffer *tmp = new_buf(MAX_RECV_SIZE);
+	if (!tmp)
+		return NULL;
+	tmp->peer = peer;
+	tmp->start += sizeof(struct payload_hdr);
+	tmp->len = 0;
+	return tmp;
 }
 
-inline void recycle_payload (struct buffer *buf, struct sockaddr_in peer)
+inline void recycle_payload(struct buffer *buf, struct sockaddr_in peer)
 {
-    buf->start = buf->rstart + sizeof (struct payload_hdr);
-    buf->len = 0;
-    buf->peer = peer;
+	buf->start = buf->rstart + sizeof(struct payload_hdr);
+	buf->len = 0;
+	buf->peer = peer;
 }
 
-void add_payload_hdr (struct tunnel *t, struct call *c, struct buffer *buf)
+void add_payload_hdr(struct tunnel *t, struct call *c, struct buffer *buf)
 {
-    struct payload_hdr *p;
+	struct payload_hdr *p;
 	printf("!!!!!!! start add payload hdr !!!\n");
-    buf->start -= sizeof (struct payload_hdr);
-    buf->len += sizeof (struct payload_hdr);
-    /* Account for no offset */
-    buf->start += 4;
-    buf->len -= 4;
-    if (!c->fbit && !c->ourfbit)
-    {
-        /* Forget about Ns and Nr fields then */
-        buf->start += 4;
-        buf->len -= 4;
-    }
-    if (!c->lbit)
-    {
-        /* Forget about specifying the length */
-        buf->start += 2;
-        buf->len -= 2;
-    }
-    p = (struct payload_hdr *) buf->start;
+	buf->start -= sizeof(struct payload_hdr);
+	buf->len += sizeof(struct payload_hdr);
+	/* Account for no offset */
+	buf->start += 4;
+	buf->len -= 4;
+	if (!c->fbit && !c->ourfbit)
+	{
+		/* Forget about Ns and Nr fields then */
+		buf->start += 4;
+		buf->len -= 4;
+	}
+	if (!c->lbit)
+	{
+		/* Forget about specifying the length */
+		buf->start += 2;
+		buf->len -= 2;
+	}
+	p = (struct payload_hdr *) buf->start;
 /*	p->ver = htons(c->lbit | c->rbit | c->fbit | c->ourfbit | VER_L2TP); */
-    p->ver = htons (c->lbit | c->fbit | c->ourfbit | VER_L2TP);
-    if (c->lbit)
-    {
-        p->length = htons ((_u16) buf->len);
-    }
-    else
-    {
-        p = (struct payload_hdr *) (((char *) p) - 2);
-    }
-    p->tid = htons (t->tid);
+	p->ver = htons(c->lbit | c->fbit | c->ourfbit | VER_L2TP);
+	if (c->lbit)
+	{
+		p->length = htons((_u16) buf->len);
+	} else
+	{
+		p = (struct payload_hdr *) (((char *) p) - 2);
+	}
+	p->tid = htons(t->tid);
 	printf("!!!!!!!!tid==%x\n", htons(t->tid));
-    p->cid = htons (c->cid);
+	p->cid = htons(c->cid);
 	printf("!!!!!!!!cid==%x\n", htons(c->cid));
-    if (c->fbit || c->ourfbit)
-    {
-        p->Ns = htons (c->data_seq_num);
-        p->Nr = htons (c->data_rec_seq_num);
-    }
-    c->data_seq_num++;
+	if (c->fbit || c->ourfbit)
+	{
+		p->Ns = htons(c->data_seq_num);
+		p->Nr = htons(c->data_rec_seq_num);
+	}
+	c->data_seq_num++;
 /*	c->rbit=0; */
 }
 
-int read_packet (struct buffer *buf, int fd, int convert)
+int read_packet(struct buffer *buf, int fd, int convert)
 {
-    unsigned char c;
-    unsigned char escape = 0;
-    unsigned char *p;
-    static unsigned char rbuf[MAX_RECV_SIZE];
-    static int pos = 0;
-    static int max = 0;
-    int res;
-    int errors = 0;
-    /* Read a packet, doing async->sync conversion if necessary */
-    p = buf->start;
-    while (1)
-    {
-        if (pos >= max)
-        {
-            max = read (fd, rbuf, sizeof (rbuf));
-            res = max;
-            pos = 0;
-        }
-        else
-        {
-            res = 1;
-        }
-        c = rbuf[pos++];
-        if (res < 1)
-        {
-            if (res == 0)
-            {
-                /*
-                   * Hmm..  Nothing to read.  It happens
-                 */
-                return 0;
+	unsigned char c;
+	unsigned char escape = 0;
+	unsigned char *p;
+	static unsigned char rbuf[MAX_RECV_SIZE];
+	static int pos = 0;
+	static int max = 0;
+	int res;
+	int errors = 0;
+	/* Read a packet, doing async->sync conversion if necessary */
+	p = buf->start;
+	while (1)
+	{
+		if (pos >= max)
+		{
+			max = read(fd, rbuf, sizeof(rbuf));
+			res = max;
+			pos = 0;
+		} else
+		{
+			res = 1;
+		}
+		c = rbuf[pos++];
+		if (res < 1)
+		{
+			if (res == 0)
+			{
+				/*
+				 * Hmm..  Nothing to read.  It happens
+				 */
+				return 0;
 /*			} else if ((errno == EINTR ) || (errno == EAGAIN)) { */
-            }
-            else if ((errno == EIO) || (errno == EINTR) || (errno == EAGAIN))
-            {
-
-                /*
-                   * Oops, we were interrupted!
-                   * Or, we ran out of data too soon
-                   * anyway, we discared whatever it is we
-                   * have
-                 */
-                return 0;
-            }
-            errors++;
-            log (LOG_DEBUG, "%s: Error %d (%s)\n", __FUNCTION__, errno,
-                 strerror (errno));
-            if (errors > 10)
-            {
-                log (LOG_DEBUG,
-                     "%s: Too many errors.  Declaring call dead.\n",
-                     __FUNCTION__);
-                return -errno;
-            }
-            continue;
-        }
-        switch (c)
-        {
-        case PPP_FLAG:
-            if (escape)
-            {
-                log (LOG_DEBUG, "%s: got an escaped PPP_FLAG\n",
-                     __FUNCTION__);
-                return -EINVAL;
-            }
-            if (convert)
-            {
-                if (!buf->len)
-                    break;
-                /* Drop the FCS */
-                buf->len -= 2;
-            }
-            else
-            {
-                if (buf->len < buf->maxlen)
-                {
-                    *p = c;
-                    p++;
-                    buf->len++;
-                }
-            }
-            return buf->len;
-        case PPP_ESCAPE:
-            escape = PPP_TRANS;
-            if (convert)
-                break;
-        default:
-            if (convert)
-                c ^= escape;
-            escape = 0;
-            if (buf->len < buf->maxlen)
-            {
-                *p = c;
-                p++;
-                buf->len++;
-                break;
-            };
-            log (LOG_WARN, "%s: read overrun\n", __FUNCTION__);
-            return -EINVAL;
-        }
-    }
-    /* I should never get here */
-    log (LOG_WARN, "%s: You should not see this message.  If you do, please
+			} else if ((errno == EIO) || (errno == EINTR) || (errno == EAGAIN))
+			{
+
+				/*
+				 * Oops, we were interrupted!
+				 * Or, we ran out of data too soon
+				 * anyway, we discared whatever it is we
+				 * have
+				 */
+				return 0;
+			}
+			errors++;
+			log(LOG_DEBUG, "%s: Error %d (%s)\n", __FUNCTION__, errno, strerror(errno));
+			if (errors > 10)
+			{
+				log(LOG_DEBUG, "%s: Too many errors.  Declaring call dead.\n", __FUNCTION__);
+				return -errno;
+			}
+			continue;
+		}
+		switch (c)
+		{
+		case PPP_FLAG:
+			if (escape)
+			{
+				log(LOG_DEBUG, "%s: got an escaped PPP_FLAG\n", __FUNCTION__);
+				return -EINVAL;
+			}
+			if (convert)
+			{
+				if (!buf->len)
+					break;
+				/* Drop the FCS */
+				buf->len -= 2;
+			} else
+			{
+				if (buf->len < buf->maxlen)
+				{
+					*p = c;
+					p++;
+					buf->len++;
+				}
+			}
+			return buf->len;
+		case PPP_ESCAPE:
+			escape = PPP_TRANS;
+			if (convert)
+				break;
+		default:
+			if (convert)
+				c ^= escape;
+			escape = 0;
+			if (buf->len < buf->maxlen)
+			{
+				*p = c;
+				p++;
+				buf->len++;
+				break;
+			};
+			log(LOG_WARN, "%s: read overrun\n", __FUNCTION__);
+			return -EINVAL;
+		}
+	}
+	/* I should never get here */
+	log(LOG_WARN, "%s: You should not see this message.  If you do, please
 		       enter a bug report at http://sourceforge.net/projects/l2tpd", __FUNCTION__);
-    return -EINVAL;
+	return -EINVAL;
 }
 
-void call_close (struct call *c)
+void call_close(struct call *c)
 {
-    struct buffer *buf;
-    struct schedule_entry *se, *ose;
-    struct call *tmp, *tmp2;
-    if (!c || !c->container)
-    {
-        log (LOG_DEBUG, "%s: called on null call or containerless call\n",
-             __FUNCTION__);
-        return;
-    }
-    if (c == c->container->self)
-    {
-        /*
-         * We're actually closing the
-         * entire tunnel
-         */
-
-        /* First deschedule any remaining packet transmissions
-           for this tunnel.  That means Hello's and any reminaing
-           packets scheduled for transmission.  This is a very
-           nasty little piece of code here. */
-
-        se = events;
-        ose = NULL;
-        while (se)
-        {
-            if ((((struct buffer *) se->data)->tunnel == c->container)
-                || ((struct tunnel *) se->data == c->container))
-            {
+	struct buffer *buf;
+	struct schedule_entry *se, *ose;
+	struct call *tmp, *tmp2;
+	if (!c || !c->container)
+	{
+		log(LOG_DEBUG, "%s: called on null call or containerless call\n", __FUNCTION__);
+		return;
+	}
+	if (c == c->container->self)
+	{
+		/*
+		 * We're actually closing the
+		 * entire tunnel
+		 */
+
+		/* First deschedule any remaining packet transmissions
+		   for this tunnel.  That means Hello's and any reminaing
+		   packets scheduled for transmission.  This is a very
+		   nasty little piece of code here. */
+
+		se = events;
+		ose = NULL;
+		while (se)
+		{
+			if ((((struct buffer *) se->data)->tunnel == c->container) || ((struct tunnel *) se->data == c->container))
+			{
 #ifdef DEBUG_CLOSE
-                log (LOG_DEBUG, "%s: Descheduling event\n", __FUNCTION__);
+				log(LOG_DEBUG, "%s: Descheduling event\n", __FUNCTION__);
 #endif
-                if (ose)
-                {
-                    ose->next = se->next;
-                    if ((struct tunnel *) se->data != c->container)
-                        toss ((struct buffer *) (se->data));
-                    free (se);
-                    se = ose->next;
-                }
-                else
-                {
-                    events = se->next;
-                    if ((struct tunnel *) se->data != c->container)
-                        toss ((struct buffer *) (se->data));
-                    free (se);
-                    se = events;
-                }
-            }
-            else
-            {
-                ose = se;
-                se = se->next;
-            }
-        }
-
-        if (c->closing)
-        {
-            /* Really close this tunnel, as our
-               StopCCN has been ack'd */
+				if (ose)
+				{
+					ose->next = se->next;
+					if ((struct tunnel *) se->data != c->container)
+						toss((struct buffer *) (se->data));
+					free(se);
+					se = ose->next;
+				} else
+				{
+					events = se->next;
+					if ((struct tunnel *) se->data != c->container)
+						toss((struct buffer *) (se->data));
+					free(se);
+					se = events;
+				}
+			} else
+			{
+				ose = se;
+				se = se->next;
+			}
+		}
+
+		if (c->closing)
+		{
+			/* Really close this tunnel, as our
+			   StopCCN has been ack'd */
 #ifdef DEBUG_CLOSE
-            log (LOG_DEBUG, "%s: Actually closing tunnel %d\n", __FUNCTION__,
-                 c->container->ourtid);
+			log(LOG_DEBUG, "%s: Actually closing tunnel %d\n", __FUNCTION__, c->container->ourtid);
 #endif
 #ifdef USE_KERNEL
-            if (kernel_support)
-                ioctl (server_socket, L2TPIOCDELTUNNEL, c->container->ourtid);
+			if (kernel_support)
+				ioctl(server_socket, L2TPIOCDELTUNNEL, c->container->ourtid);
 #endif
-            destroy_tunnel (c->container);
-            return;
-        }
-
-        /*
-           * We need to close, but need to provide reliable delivery
-           * of the final StopCCN. We record our state to know when
-           * we have actually received an ACK on our StopCCN
-         */
-        c->closeSs = c->container->control_seq_num;
-        buf = new_outgoing (c->container);
-        add_message_type_avp (buf, StopCCN);
-        if (c->container->hbit)
-        {
-            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, c->container->chal_them.vector,
-                              VECTOR_SIZE);
-        }
-        add_tunnelid_avp (buf, c->container->ourtid);
-        if (c->result < 0)
-            c->result = RESULT_CLEAR;
-        if (c->error < 0)
-            c->error = 0;
-        add_result_code_avp (buf, c->result, c->error, c->errormsg,
-                             strlen (c->errormsg));
-        add_control_hdr (c->container, c, buf);
-        if (packet_dump)
-            do_packet_dump (buf);
+			destroy_tunnel(c->container);
+			return;
+		}
+
+		/*
+		 * We need to close, but need to provide reliable delivery
+		 * of the final StopCCN. We record our state to know when
+		 * we have actually received an ACK on our StopCCN
+		 */
+		c->closeSs = c->container->control_seq_num;
+		buf = new_outgoing(c->container);
+		add_message_type_avp(buf, StopCCN);
+		if (c->container->hbit)
+		{
+			mk_challenge(c->container->chal_them.vector, VECTOR_SIZE);
+			add_randvect_avp(buf, c->container->chal_them.vector, VECTOR_SIZE);
+		}
+		add_tunnelid_avp(buf, c->container->ourtid);
+		if (c->result < 0)
+			c->result = RESULT_CLEAR;
+		if (c->error < 0)
+			c->error = 0;
+		add_result_code_avp(buf, c->result, c->error, c->errormsg, strlen(c->errormsg));
+		add_control_hdr(c->container, c, buf);
+		if (packet_dump)
+			do_packet_dump(buf);
 #ifdef DEBUG_CLOSE
-        log (LOG_DEBUG, "%s: enqueing close message for tunnel\n",
-             __FUNCTION__);
+		log(LOG_DEBUG, "%s: enqueing close message for tunnel\n", __FUNCTION__);
 #endif
-        control_xmit (buf);
-        /*
-           * We also need to stop all traffic on any calls contained
-           * within us.
-         */
-        tmp = c->container->call_head;
-        while (tmp)
-        {
-            tmp2 = tmp->next;
-            tmp->needclose = 0;
-            tmp->closing = -1;
-            call_close (tmp);
-            tmp = tmp2;
-        }
-        log (LOG_LOG,
-             "Connection %d closed to %s, port %d (%s)\n", 
-             c->container->tid,
-             IPADDY (c->container->peer.sin_addr),
-             ntohs (c->container->peer.sin_port), c->errormsg);
-    }
-    else
-    {
-        /*
-           * Just close a call
-         */
+		control_xmit(buf);
+		/*
+		 * We also need to stop all traffic on any calls contained
+		 * within us.
+		 */
+		tmp = c->container->call_head;
+		while (tmp)
+		{
+			tmp2 = tmp->next;
+			tmp->needclose = 0;
+			tmp->closing = -1;
+			call_close(tmp);
+			tmp = tmp2;
+		}
+		log(LOG_LOG, "Connection %d closed to %s, port %d (%s)\n", c->container->tid, IPADDY(c->container->peer.sin_addr), ntohs(c->container->peer.sin_port), c->errormsg);
+	} else
+	{
+		/*
+		 * Just close a call
+		 */
 #ifdef USE_KERNEL
-        struct l2tp_call_opts co;
+		struct l2tp_call_opts co;
 #endif
-        if (c->zlb_xmit)
-            deschedule (c->zlb_xmit);
+		if (c->zlb_xmit)
+			deschedule(c->zlb_xmit);
 /*		if (c->dethrottle) deschedule(c->dethrottle); */
-        if (c->closing)
-        {
+		if (c->closing)
+		{
 #ifdef DEBUG_CLOSE
-            log (LOG_DEBUG, "%s: Actually closing call %d\n", __FUNCTION__,
-                 c->ourcid);
+			log(LOG_DEBUG, "%s: Actually closing call %d\n", __FUNCTION__, c->ourcid);
 #endif
-            destroy_call (c);
-            return;
-        }
+			destroy_call(c);
+			return;
+		}
 #ifdef USE_KERNEL
-        if (kernel_support)
-        {
-            co.ourtid = c->container->ourtid;
-            co.ourcid = c->ourcid;
-            ioctl (server_socket, L2TPIOCGETCALLOPTS, &co);
-            co.flags = co.flags & ~L2TP_FLAG_CALL_UP;
-            ioctl (server_socket, L2TPIOCSETCALLOPTS, &co);
-        }
-#endif
-        c->closeSs = c->container->control_seq_num;
-        buf = new_outgoing (c->container);
-        add_message_type_avp (buf, CDN);
-        if (c->container->hbit)
-        {
-            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, c->container->chal_them.vector,
-                              VECTOR_SIZE);
-        }
-        if (c->result < 0)
-            c->result = RESULT_CLEAR;
-        if (c->error < 0)
-            c->error = 0;
-        add_result_code_avp (buf, c->result, c->error, c->errormsg,
-                             strlen (c->errormsg));
+		if (kernel_support)
+		{
+			co.ourtid = c->container->ourtid;
+			co.ourcid = c->ourcid;
+			ioctl(server_socket, L2TPIOCGETCALLOPTS, &co);
+			co.flags = co.flags & ~L2TP_FLAG_CALL_UP;
+			ioctl(server_socket, L2TPIOCSETCALLOPTS, &co);
+		}
+#endif
+		c->closeSs = c->container->control_seq_num;
+		buf = new_outgoing(c->container);
+		add_message_type_avp(buf, CDN);
+		if (c->container->hbit)
+		{
+			mk_challenge(c->container->chal_them.vector, VECTOR_SIZE);
+			add_randvect_avp(buf, c->container->chal_them.vector, VECTOR_SIZE);
+		}
+		if (c->result < 0)
+			c->result = RESULT_CLEAR;
+		if (c->error < 0)
+			c->error = 0;
+		add_result_code_avp(buf, c->result, c->error, c->errormsg, strlen(c->errormsg));
 #ifdef TEST_HIDDEN
-        add_callid_avp (buf, c->ourcid, c->container);
+		add_callid_avp(buf, c->ourcid, c->container);
 #else
-        add_callid_avp (buf, c->ourcid);
+		add_callid_avp(buf, c->ourcid);
 #endif
-        add_control_hdr (c->container, c, buf);
-        if (packet_dump)
-            do_packet_dump (buf);
+		add_control_hdr(c->container, c, buf);
+		if (packet_dump)
+			do_packet_dump(buf);
 #ifdef DEBUG_CLOSE
-        log (LOG_DEBUG, "%s: enqueuing close message for call %d\n",
-             __FUNCTION__, c->ourcid);
+		log(LOG_DEBUG, "%s: enqueuing close message for call %d\n", __FUNCTION__, c->ourcid);
 #endif
-        control_xmit (buf);
-        log (LOG_LOG, "%s: Call %d to %s disconnected\n", __FUNCTION__,
-             c->ourcid, IPADDY (c->container->peer.sin_addr));
-    }
-    /*
-       * Note that we're in the process of closing now
-     */
-    c->closing = -1;
+		control_xmit(buf);
+		log(LOG_LOG, "%s: Call %d to %s disconnected\n", __FUNCTION__, c->ourcid, IPADDY(c->container->peer.sin_addr));
+	}
+	/*
+	 * Note that we're in the process of closing now
+	 */
+	c->closing = -1;
 }
 
-void destroy_call (struct call *c)
+void destroy_call(struct call *c)
 {
-    /*
-     * Here, we unconditionally destroy a call.
-     */
-
-    struct call *p;
-    struct timeval tv;
-    pid_t pid;
-    /*
-     * Close the tty
-     */
-    if (c->fd > 0)
-        close (c->fd);
+	/*
+	 * Here, we unconditionally destroy a call.
+	 */
+
+	struct call *p;
+	struct timeval tv;
+	pid_t pid;
+	/*
+	 * Close the tty
+	 */
+	if (c->fd > 0)
+		close(c->fd);
 /*	if (c->dethrottle) deschedule(c->dethrottle); */
-    if (c->zlb_xmit)
-        deschedule (c->zlb_xmit);
+	if (c->zlb_xmit)
+		deschedule(c->zlb_xmit);
 
 #ifdef IP_ALLOCATION
-    if (c->addr)
-        unreserve_addr (c->addr);
+	if (c->addr)
+		unreserve_addr(c->addr);
 #endif
 
-    /*
-     * Kill off pppd and wait for it to 
-     * return to us.  This should only be called
-     * in rare cases if pppd hasn't already died
-     * voluntarily
-     */
-    pid = c->pppd;
-    if (pid)
-    {
-        /* Set c->pppd to zero to prevent recursion with child_handler */
-        c->pppd = 0;
-        kill (pid, SIGTERM);
-        waitpid (pid, NULL, 0);
-    }
-    if (c->container)
-    {
+	/*
+	 * Kill off pppd and wait for it to 
+	 * return to us.  This should only be called
+	 * in rare cases if pppd hasn't already died
+	 * voluntarily
+	 */
+	pid = c->pppd;
+	if (pid)
+	{
+		/* Set c->pppd to zero to prevent recursion with child_handler */
+		c->pppd = 0;
+		dbg("%s(): send SITERM to pid %d\n", __FUNCTION__, pid);	//eric++
+		kill(pid, SIGTERM);
+		waitpid(pid, NULL, 0);
+	}
+	if (c->container)
+	{
 #ifdef USE_KERNEL
-        if (kernel_support)
-            ioctl (server_socket, L2TPIOCDELCALL,
-                   (c->container->ourtid << 16) | (c->ourcid));
-#endif
-        p = c->container->call_head;
-        /*
-         * Remove us from the call list, although
-         * we might not actually be there
-         */
-        if (p)
-        {
-            if (p == c)
-            {
-                c->container->call_head = c->next;
-                c->container->count--;
-            }
-            else
-            {
-                while (p->next && (p->next != c))
-                    p = p->next;
-                if (p->next)
-                {
-                    p->next = c->next;
-                    c->container->count--;
-                }
-            }
-        }
-    }
-    if (c->lac)
-    {
-        c->lac->c = NULL;
-        if (c->lac->redial && (c->lac->rtimeout > 0) && !c->lac->rsched &&
-            c->lac->active)
-        {
+		if (kernel_support)
+			ioctl(server_socket, L2TPIOCDELCALL, (c->container->ourtid << 16) | (c->ourcid));
+#endif
+		p = c->container->call_head;
+		/*
+		 * Remove us from the call list, although
+		 * we might not actually be there
+		 */
+		if (p)
+		{
+			if (p == c)
+			{
+				c->container->call_head = c->next;
+				c->container->count--;
+			} else
+			{
+				while (p->next && (p->next != c))
+					p = p->next;
+				if (p->next)
+				{
+					p->next = c->next;
+					c->container->count--;
+				}
+			}
+		}
+	}
+	if (c->lac)
+	{
+		c->lac->c = NULL;
+		if (c->lac->redial && (c->lac->rtimeout > 0) && !c->lac->rsched && c->lac->active)
+		{
 #ifdef DEBUG_MAGIC
-            log (LOG_LOG, "Will redial in %d seconds\n",
-                 c->lac->rtimeout);
+			log(LOG_LOG, "Will redial in %d seconds\n", c->lac->rtimeout);
 #endif
-            tv.tv_sec = c->lac->rtimeout;
-            tv.tv_usec = 0;
-            c->lac->rsched = schedule (tv, magic_lac_dial, c->lac);
-        }
-    }
+			tv.tv_sec = c->lac->rtimeout;
+			tv.tv_usec = 0;
+			c->lac->rsched = schedule(tv, magic_lac_dial, c->lac);
+		}
+	}
 
-    free (c);
+	free(c);
 
 }
 
 
-struct call *new_call (struct tunnel *parent)
+struct call *new_call(struct tunnel *parent)
 {
-    char entropy_buf[2] = "\0";
-    struct call *tmp = malloc (sizeof (struct call));
+	char entropy_buf[2] = "\0";
+	struct call *tmp = malloc(sizeof(struct call));
 
-    if (!tmp)
-        return NULL;
-    tmp->tx_pkts = 0;
-    tmp->rx_pkts = 0;
-    tmp->tx_bytes = 0;
-    tmp->rx_bytes = 0;
-    tmp->zlb_xmit = NULL;
+	if (!tmp)
+		return NULL;
+	tmp->tx_pkts = 0;
+	tmp->rx_pkts = 0;
+	tmp->tx_bytes = 0;
+	tmp->rx_bytes = 0;
+	tmp->zlb_xmit = NULL;
 /*	tmp->throttle = 0; */
 /*	tmp->dethrottle=NULL; */
-    tmp->prx = 0;
+	tmp->prx = 0;
 /*	tmp->rbit = 0; */
-    tmp->msgtype = 0;
+	tmp->msgtype = 0;
 /*	tmp->timeout = 0; */
-    tmp->data_seq_num = 0;
-    tmp->data_rec_seq_num = 0;
-    tmp->pLr = -1;
-    tmp->nego = 0;
-    tmp->debug = 0;
-    tmp->seq_reqd = 0;
-    tmp->state = 0;             /* Nothing so far */
-    if (parent->self)
-    {
+	tmp->data_seq_num = 0;
+	tmp->data_rec_seq_num = 0;
+	tmp->pLr = -1;
+	tmp->nego = 0;
+	tmp->debug = 0;
+	tmp->seq_reqd = 0;
+	tmp->state = 0;				/* Nothing so far */
+	if (parent->self)
+	{
 #ifndef TESTING
 #ifdef USE_KERNEL
-        if (kernel_support)
-            tmp->ourcid =
-                ioctl (server_socket, L2TPIOCADDCALL, parent->ourtid << 16);
-        else
+		if (kernel_support)
+			tmp->ourcid = ioctl(server_socket, L2TPIOCADDCALL, parent->ourtid << 16);
+		else
 #endif
 /*	while(get_call(parent->ourtid, (tmp->ourcid = (rand() && 0xFFFF)),0,0)); */
-            /* FIXME: What about possibility of multiple random #'s??? */
-            /* tmp->ourcid = (rand () & 0xFFFF); */
-            get_entropy(entropy_buf, 2);
-        {
-            unsigned short *temp;
-            temp = (unsigned short *)entropy_buf;
-            tmp->ourcid = *temp & 0xFFFF;
+			/* FIXME: What about possibility of multiple random #'s??? */
+			/* tmp->ourcid = (rand () & 0xFFFF); */
+			get_entropy(entropy_buf, 2);
+		{
+			unsigned short *temp;
+			temp = (unsigned short *) entropy_buf;
+			tmp->ourcid = *temp & 0xFFFF;
 #ifdef DEBUG_ENTROPY
-            log(LOG_DEBUG, "ourcid = %u, entropy_buf = %hx\n", tmp->ourcid, *temp);
+			log(LOG_DEBUG, "ourcid = %u, entropy_buf = %hx\n", tmp->ourcid, *temp);
 #endif
-        }
+		}
 #else
-        tmp->ourcid = 0x6227;
+		tmp->ourcid = 0x6227;
 #endif
-    }
-    tmp->dialed[0] = 0;
-    tmp->dialing[0] = 0;
-    tmp->subaddy[0] = 0;
-    tmp->physchan = -1;
-    tmp->serno = 0;
-    tmp->bearer = -1;
-    tmp->cid = -1;
-    tmp->qcid = -1;
-    tmp->container = parent;
+	}
+	tmp->dialed[0] = 0;
+	tmp->dialing[0] = 0;
+	tmp->subaddy[0] = 0;
+	tmp->physchan = -1;
+	tmp->serno = 0;
+	tmp->bearer = -1;
+	tmp->cid = -1;
+	tmp->qcid = -1;
+	tmp->container = parent;
 /*	tmp->rws = -1; */
-    tmp->fd = -1;
-    tmp->oldptyconf = malloc (sizeof (struct termios));
-    tmp->pnu = 0;
-    tmp->cnu = 0;
-    tmp->needclose = 0;
-    tmp->closing = 0;
-    tmp->die = 0;
-    tmp->pppd = 0;
-    tmp->error = -1;
-    tmp->result = -1;
-    tmp->errormsg[0] = 0;
-    tmp->fbit = 0;
-    tmp->cid = 0;
-    tmp->lbit = 0;
-    /* Inherit LAC and LNS from parent */
-    tmp->lns = parent->lns;
-    tmp->lac = parent->lac;
-    tmp->addr = 0;
+	tmp->fd = -1;
+	tmp->oldptyconf = malloc(sizeof(struct termios));
+	tmp->pnu = 0;
+	tmp->cnu = 0;
+	tmp->needclose = 0;
+	tmp->closing = 0;
+	tmp->die = 0;
+	tmp->pppd = 0;
+	tmp->error = -1;
+	tmp->result = -1;
+	tmp->errormsg[0] = 0;
+	tmp->fbit = 0;
+	tmp->cid = 0;
+	tmp->lbit = 0;
+	/* Inherit LAC and LNS from parent */
+	tmp->lns = parent->lns;
+	tmp->lac = parent->lac;
+	tmp->addr = 0;
 /*	tmp->ourrws = DEFAULT_RWS_SIZE;	 */
 /*	if (tmp->ourrws >= 0)
 		tmp->ourfbit = FBIT;
 	else */
-    tmp->ourfbit = 0;           /* initialize to 0 since we don't actually use this 
-                                   value at this point anywhere in the code (I don't 
-                                   think)  We might just be able to remove it completely */
-    tmp->dial_no[0] = '\0';     /* jz: dialing number for outgoing call */
-    return tmp;
+	tmp->ourfbit = 0;			/* initialize to 0 since we don't actually use this 
+								   value at this point anywhere in the code (I don't 
+								   think)  We might just be able to remove it completely */
+	tmp->dial_no[0] = '\0';		/* jz: dialing number for outgoing call */
+	return tmp;
 }
 
-struct call *get_tunnel (int tunnel, unsigned int addr, int port)
+struct call *get_tunnel(int tunnel, unsigned int addr, int port)
 {
-    struct tunnel *st;
-    if (tunnel)
-    {
-        st = tunnels.head;
-        while (st)
-        {
-            if (st->ourtid == tunnel)
-            {
-                return st->self;
-            }
-            st = st->next;
-        }
-    }
-    return NULL;
+	struct tunnel *st;
+	if (tunnel)
+	{
+		st = tunnels.head;
+		while (st)
+		{
+			if (st->ourtid == tunnel)
+			{
+				return st->self;
+			}
+			st = st->next;
+		}
+	}
+	return NULL;
 }
-struct call *get_call (int tunnel, int call, unsigned int addr, int port)
+struct call *get_call(int tunnel, int call, unsigned int addr, int port)
 {
-    /*
-     * Figure out which call struct should handle this. 
-     * If we have tunnel and call ID's then they are unique.
-     * Otherwise, if the tunnel is 0, look for an existing connection
-     * or create a new tunnel.
-     */
-    struct tunnel *st;
-    struct call *sc;
-    if (tunnel)
-    {
-        st = tunnels.head;
-        while (st)
-        {
-            if (st->ourtid == tunnel)
-            {
-                if (call)
-                {
-                    sc = st->call_head;
-                    while (sc)
-                    {
-                        if (sc->ourcid == call)
-                            return sc;
-                        sc = sc->next;
-                    }
-                    log (LOG_DEBUG, "%s: can't find call %d in tunnel %d\n",
-                         __FUNCTION__, call, tunnel);
-                    return NULL;
-                }
-                else
-                {
-                    return st->self;
-                }
-            }
-            st = st->next;
-        }
-        log (LOG_DEBUG, "%s:can't find tunnel %d\n", __FUNCTION__, tunnel);
-        return NULL;
-    }
-    else
-    {
+	/*
+	 * Figure out which call struct should handle this. 
+	 * If we have tunnel and call ID's then they are unique.
+	 * Otherwise, if the tunnel is 0, look for an existing connection
+	 * or create a new tunnel.
+	 */
+	struct tunnel *st;
+	struct call *sc;
+//	dbg("%s(): tunnel %d call %d addr %d port %d\n", __FUNCTION__, tunnel, call, addr, port);	//eric++
+	if (tunnel)
+	{
+		st = tunnels.head;
+		while (st)
+		{
+			if (st->ourtid == tunnel)
+			{
+				if (call)
+				{
+					sc = st->call_head;
+					while (sc)
+					{
+						if (sc->ourcid == call)
+							return sc;
+						sc = sc->next;
+					}
+					log(LOG_DEBUG, "%s: can't find call %d in tunnel %d\n", __FUNCTION__, call, tunnel);
+					return NULL;
+				} else
+				{
+					return st->self;
+				}
+			}
+			st = st->next;
+		}
+		log(LOG_DEBUG, "%s:can't find tunnel %d\n", __FUNCTION__, tunnel);
+		return NULL;
+	} else
+	{
 #ifdef USE_KERNEL
-        struct l2tp_tunnel_opts to;
+		struct l2tp_tunnel_opts to;
 #endif
-        /* You can't specify a call number if you haven't specified
-           a tunnel silly! */
+		/* You can't specify a call number if you haven't specified
+		   a tunnel silly! */
 
-        if (call)
-        {
-            log (LOG_WARN,
-                 "%s: call ID specified, but no tunnel ID specified.  tossing.\n",
-                 __FUNCTION__);
-            return NULL;
-        }
-        /*
-         * Well, nothing appropriate...  Let's add a new tunnel, if
-         * we are not at capacity.
-         */
-        if (debug_tunnel)
-        {
-            log (LOG_DEBUG,
-                 "%s: allocating new tunnel for host %s, port %d.\n",
-                 __FUNCTION__, IPADDY (addr), ntohs (port));
-        }
-        if (!(st = new_tunnel ()))
-        {
-            log (LOG_WARN,
-                 "%s: unable to allocate new tunnel for host %s, port %d.\n",
-                 __FUNCTION__, IPADDY (addr), ntohs (port));
-            return NULL;
-        };
-        st->peer.sin_family = AF_INET;
-        st->peer.sin_port = port;
-        bcopy (&addr, &st->peer.sin_addr, sizeof (addr));
+		if (call)
+		{
+			log(LOG_WARN, "%s: call ID specified, but no tunnel ID specified.  tossing.\n", __FUNCTION__);
+			return NULL;
+		}
+		/*
+		 * Well, nothing appropriate...  Let's add a new tunnel, if
+		 * we are not at capacity.
+		 */
+		if (debug_tunnel)
+		{
+			log(LOG_DEBUG, "%s: allocating new tunnel for host %s, port %d.\n", __FUNCTION__, IPADDY(addr), ntohs(port));
+		}
+		if (!(st = new_tunnel()))
+		{
+			log(LOG_WARN, "%s: unable to allocate new tunnel for host %s, port %d.\n", __FUNCTION__, IPADDY(addr), ntohs(port));
+			return NULL;
+		};
+		st->peer.sin_family = AF_INET;
+		st->peer.sin_port = port;
+		bcopy(&addr, &st->peer.sin_addr, sizeof(addr));
 #ifdef USE_KERNEL
-        if (kernel_support)
-        {
-            /* Update kernel as to peer's location */
-            to.ourtid = st->ourtid;
-            ioctl (server_socket, L2TPIOCGETTUNOPTS, &to);
-            bcopy (&st->peer, &to.peer, sizeof (st->peer));
-            to.addrlen = sizeof (st->peer);
-            ioctl (server_socket, L2TPIOCSETTUNOPTS, &to);
-        }
-#endif
-        st->next = tunnels.head;
-        tunnels.head = st;
-        tunnels.count++;
-        return st->self;
-    }
+		if (kernel_support)
+		{
+			/* Update kernel as to peer's location */
+			to.ourtid = st->ourtid;
+			ioctl(server_socket, L2TPIOCGETTUNOPTS, &to);
+			bcopy(&st->peer, &to.peer, sizeof(st->peer));
+			to.addrlen = sizeof(st->peer);
+			ioctl(server_socket, L2TPIOCSETTUNOPTS, &to);
+		}
+#endif
+		st->next = tunnels.head;
+		tunnels.head = st;
+		tunnels.count++;
+		return st->self;
+	}
 }
diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/l2tpd.c l2tpd.20051227/l2tpd.c
--- l2tpd.orig/l2tpd.c	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/l2tpd.c	2005-12-27 16:52:30.000000000 +0800
@@ -49,1154 +49,1099 @@
 struct tunnel_list tunnels;
 int max_tunnels = DEF_MAX_TUNNELS;
 struct utsname uts;
-int ppd = 1;                    /* Packet processing delay */
-int control_fd;                 /* descriptor of control area */
+int ppd = 1;					/* Packet processing delay */
+int control_fd;					/* descriptor of control area */
 char *args;
-char lns_server_name[64];	// Cheni & SJ_Yen
+char lns_server_name[64];		// Cheni & SJ_Yen
 
 
-char *dial_no_tmp;              /* jz: Dialnumber for Outgoing Call */
-int switch_io = 0;              /* jz: Switch for Incoming or Outgoing Call */
+char *dial_no_tmp;				/* jz: Dialnumber for Outgoing Call */
+int switch_io = 0;				/* jz: Switch for Incoming or Outgoing Call */
 
 
-void init_tunnel_list (struct tunnel_list *t)
+void init_tunnel_list(struct tunnel_list *t)
+{
+	t->head = NULL;
+	t->count = 0;
+	t->calls = 0;
+}
 
+void show_status(int fd)
 {
-    t->head = NULL;
-    t->count = 0;
-    t->calls = 0;
-}
-
-void show_status (int fd)
-{
-    struct schedule_entry *se;
-    struct tunnel *t;
-    struct call *c;
-    struct lns *tlns;
-    struct lac *tlac;
-    struct host *h;
-    int s = 0;
-    int fd2 = dup (fd);
-    FILE *f = fdopen (fd2, "a");
-    if (!f)
-    {
-        log (LOG_WARN, "show_status: fdopen() failed on fd %d\n", fd2);
-        return;
-    }
-    fprintf (f, "====== l2tpd statistics ========\n");
-    fprintf (f, " Scheduler entries:\n");
-    se = events;
-    while (se)
-    {
-        s++;
-        t = (struct tunnel *) se->data;
-        tlac = (struct lac *) se->data;
-        c = (struct call *) se->data;
-        if (se->func == &hello)
-        {
-            fprintf (f, "%d: HELLO to %d\n", s, t->tid);
-        }
-        else if (se->func == &magic_lac_dial)
-        {
-            fprintf (f, "%d: Magic dial on %s\n", s, tlac->entname);
-        }
-        else if (se->func == &send_zlb)
-        {
-            fprintf (f, "%d: Send payload ZLB on call %d:%d\n", s,
-                     c->container->tid, c->cid);
-        }
-        else if (se->func == &dethrottle)
-        {
-            fprintf (f, "%d: Dethrottle call %d:%d\n", s, c->container->tid,
-                     c->cid);
-        }
-        else
-            fprintf (f, "%d: Unknown event\n", s);
-        se = se->next;
-    };
-    fprintf (f, "Total Events scheduled: %d\n", s);
-    fprintf (f, "Number of tunnels open: %d\n", tunnels.count);
-    fprintf (f, "Highest file descriptor: %d\n", fd2);
-    t = tunnels.head;
-    while (t)
-    {
-        fprintf (f, "Tunnel %s, ID = %d (local), %d (remote) to %s:%d\n"
-                 "   control_seq_num = %d, control_rec_seq_num = %d,\n"
-                 "   cLr = %d\n",
-                 (t->lac ? t->lac->entname : (t->lns ? t->lns->entname : "")),
-                 t->ourtid, t->tid, IPADDY (t->peer.sin_addr),
-                 ntohs (t->peer.sin_port), t->control_seq_num,
-                 t->control_rec_seq_num, t->cLr);
-        c = t->call_head;
-        while (c)
-        {
-            fprintf (f,
-                     "Call %s, ID = %d (local), %d (remote), serno = %u,\n"
-                     "      data_seq_num = %d, data_rec_seq_num = %d,\n"
-                     "      pLr = %d, tx = %u bytes (%u), rx= %u bytes (%u)\n",
-                     (c->lac ? c->lac->
-                      entname : (c->lns ? c->lns->entname : "")), c->ourcid,
-                     c->cid, c->serno, c->data_seq_num, c->data_rec_seq_num,
-                     c->pLr, c->tx_bytes, c->tx_pkts, c->rx_bytes, c->rx_pkts);
-            c = c->next;
-        }
-        t = t->next;
-    }
-    fprintf (f, "==========Config File===========\n");
-    tlns = lnslist;
-    while (tlns)
-    {
-        fprintf (f, "LNS entry %s\n",
-                 tlns->entname[0] ? tlns->entname : "(unnamed)");
-        tlns = tlns->next;
-    };
-    tlac = laclist;
-    while (tlac)
-    {
-        fprintf (f, "LAC entry %s, LNS is/are:",
-                 tlac->entname[0] ? tlac->entname : "(unnamed)");
-        h = tlac->lns;
-        if (h)
-        {
-            while (h)
-            {
-                fprintf (f, " %s", h->hostname);
-                h = h->next;
-            }
-        }
-        else
-            fprintf (f, " [none]");
-        fprintf (f, "\n");
-        tlac = tlac->next;
-    };
-    fprintf (f, "================================\n");
-    fclose (f);
-    close (fd2);
+	struct schedule_entry *se;
+	struct tunnel *t;
+	struct call *c;
+	struct lns *tlns;
+	struct lac *tlac;
+	struct host *h;
+	int s = 0;
+	int fd2 = dup(fd);
+	FILE *f = fdopen(fd2, "a");
+	if (!f)
+	{
+		log(LOG_WARN, "show_status: fdopen() failed on fd %d\n", fd2);
+		return;
+	}
+	fprintf(f, "====== l2tpd statistics ========\n");
+	fprintf(f, " Scheduler entries:\n");
+	se = events;
+	while (se)
+	{
+		s++;
+		t = (struct tunnel *) se->data;
+		tlac = (struct lac *) se->data;
+		c = (struct call *) se->data;
+		if (se->func == &hello)
+		{
+			fprintf(f, "%d: HELLO to %d\n", s, t->tid);
+		} else if (se->func == &magic_lac_dial)
+		{
+			fprintf(f, "%d: Magic dial on %s\n", s, tlac->entname);
+		} else if (se->func == &send_zlb)
+		{
+			fprintf(f, "%d: Send payload ZLB on call %d:%d\n", s, c->container->tid, c->cid);
+		} else if (se->func == &dethrottle)
+		{
+			fprintf(f, "%d: Dethrottle call %d:%d\n", s, c->container->tid, c->cid);
+		} else
+			fprintf(f, "%d: Unknown event\n", s);
+		se = se->next;
+	};
+	fprintf(f, "Total Events scheduled: %d\n", s);
+	fprintf(f, "Number of tunnels open: %d\n", tunnels.count);
+	fprintf(f, "Highest file descriptor: %d\n", fd2);
+	t = tunnels.head;
+	while (t)
+	{
+		fprintf(f, "Tunnel %s, ID = %d (local), %d (remote) to %s:%d\n" "   control_seq_num = %d, control_rec_seq_num = %d,\n" "   cLr = %d\n", (t->lac ? t->lac->entname : (t->lns ? t->lns->entname : "")), t->ourtid, t->tid, IPADDY(t->peer.sin_addr), ntohs(t->peer.sin_port), t->control_seq_num, t->control_rec_seq_num, t->cLr);
+		c = t->call_head;
+		while (c)
+		{
+			fprintf(f, "Call %s, ID = %d (local), %d (remote), serno = %u,\n" "      data_seq_num = %d, data_rec_seq_num = %d,\n" "      pLr = %d, tx = %u bytes (%u), rx= %u bytes (%u)\n", (c->lac ? c->lac->entname : (c->lns ? c->lns->entname : "")), c->ourcid, c->cid, c->serno, c->data_seq_num, c->data_rec_seq_num, c->pLr, c->tx_bytes, c->tx_pkts, c->rx_bytes, c->rx_pkts);
+			c = c->next;
+		}
+		t = t->next;
+	}
+	fprintf(f, "==========Config File===========\n");
+	tlns = lnslist;
+	while (tlns)
+	{
+		fprintf(f, "LNS entry %s\n", tlns->entname[0] ? tlns->entname : "(unnamed)");
+		tlns = tlns->next;
+	};
+	tlac = laclist;
+	while (tlac)
+	{
+		fprintf(f, "LAC entry %s, LNS is/are:", tlac->entname[0] ? tlac->entname : "(unnamed)");
+		h = tlac->lns;
+		if (h)
+		{
+			while (h)
+			{
+				fprintf(f, " %s", h->hostname);
+				h = h->next;
+			}
+		} else
+			fprintf(f, " [none]");
+		fprintf(f, "\n");
+		tlac = tlac->next;
+	};
+	fprintf(f, "================================\n");
+	fclose(f);
+	close(fd2);
 }
 
 void null_handler(int sig)
 {
-       /* FIXME 
-        * A sighup is received when a call is terminated, unknown origine .. 
-        * I catch it and ll looks good, but .. 
-	*/
-}
-
-void status_handler (int sig)
-{
-    show_status (1);
-}
-
-void child_handler (int signal)
-{
-    /*
-     * Oops, somebody we launched was killed.
-     * It's time to reap them and close that call.
-     * But first, we have to find out what PID died.
-     * unfortunately, pppd will 
-     */
-    struct tunnel *t;
-    struct call *c;
-    pid_t pid;
-    int status;
-    t = tunnels.head;
-    pid = waitpid (-1, &status, WNOHANG);
-    if (pid < 1)
-    {
-        /*
-         * Oh well, nobody there.  Maybe we reaped it
-         * somewhere else already
-         */
-        return;
-    }
-    while (t)
-    {
-        c = t->call_head;
-        while (c)
-        {
-            if (c->pppd == pid)
-            {
-                log (LOG_DEBUG, "%s : pppd died for call %d\n", __FUNCTION__,
-                     c->cid);
-                c->needclose = -1;
-                /* 
-                 * OK...pppd died, we can go ahead and close the pty for
-                 * it
-                 */
-                close (c->fd);
-                return;
-            }
-            c = c->next;
-        }
-        t = t->next;
-    }
-}
-
-void death_handler (int signal)
-{
-    /*
-       * If we get here, somebody terminated us with a kill or a control-c.
-       * we call call_close on each tunnel twice to get a StopCCN out
-       * for each one (we can't pause to make sure it's received.
-       * Then we close the connections
-     */
-    struct tunnel *st, *st2;
-    int sec;
-    log (LOG_CRIT, "%s: Fatal signal %d received\n", __FUNCTION__, signal);
-	if (signal != SIGTERM) {
+	/* FIXME 
+	 * A sighup is received when a call is terminated, unknown origine .. 
+	 * I catch it and ll looks good, but .. 
+	 */
+}
+
+void status_handler(int sig)
+{
+	show_status(1);
+}
+
+void child_handler(int signal)
+{
+	/*
+	 * Oops, somebody we launched was killed.
+	 * It's time to reap them and close that call.
+	 * But first, we have to find out what PID died.
+	 * unfortunately, pppd will 
+	 */
+	struct tunnel *t;
+	struct call *c;
+	pid_t pid;
+	int status;
+	t = tunnels.head;
+	pid = waitpid(-1, &status, WNOHANG);
+	if (pid < 1)
+	{
+		/*
+		 * Oh well, nobody there.  Maybe we reaped it
+		 * somewhere else already
+		 */
+		return;
+	}
+	while (t)
+	{
+		c = t->call_head;
+		while (c)
+		{
+			if (c->pppd == pid)
+			{
+				log(LOG_DEBUG, "%s : pppd died for call %d\n", __FUNCTION__, c->cid);
+				c->needclose = -1;
+				/* 
+				 * OK...pppd died, we can go ahead and close the pty for
+				 * it
+				 */
+				close(c->fd);
+				return;
+			}
+			c = c->next;
+		}
+		t = t->next;
+	}
+}
+
+void death_handler(int signal)
+{
+	/*
+	 * If we get here, somebody terminated us with a kill or a control-c.
+	 * we call call_close on each tunnel twice to get a StopCCN out
+	 * for each one (we can't pause to make sure it's received.
+	 * Then we close the connections
+	 */
+	struct tunnel *st, *st2;
+	int sec;
+	dbg(">> %s(%d)\n", __FUNCTION__, signal);	//eric++
+	log(LOG_CRIT, "%s: Fatal signal %d received\n", __FUNCTION__, signal);
+	if (signal != SIGTERM)
+	{
 		st = tunnels.head;
 		while (st)
 		{
 			st2 = st->next;
-			strcpy (st->self->errormsg, "Server closing");
+			strcpy(st->self->errormsg, "Server closing");
 			sec = st->self->closing;
 			if (st->lac)
 				st->lac->redial = 0;
-			call_close (st->self);
+			call_close(st->self);
 			if (!sec)
 			{
 				st->self->closing = -1;
-				call_close (st->self);
+				call_close(st->self);
 			}
 			st = st2;
 		}
 	}
 
-    /* erase pid file */
-	unlink (gconfig.pidfile);
-	unlink (CONTROL_PIPE);
+	/* erase pid file */
+	unlink(gconfig.pidfile);
+	unlink(CONTROL_PIPE);
 
-    exit (1);
+	dbg("<< %s(%d) exit(1)\n", __FUNCTION__);	//eric++
+	exit(1);
 }
 
-int start_pppd (struct call *c, struct ppp_opts *opts)
+int start_pppd(struct call *c, struct ppp_opts *opts)
 {
-    char a, b;
-    char tty[80];
-    char *stropt[80];
-    struct ppp_opts *p;
+	char a, b;
+	char tty[80];
+	char *stropt[80];
+	struct ppp_opts *p;
 #ifdef USE_KERNEL
-    struct l2tp_call_opts co;
+	struct l2tp_call_opts co;
 #endif
-    int pos = 1;
-    int fd2;
+	int pos = 1;
+	int fd2;
 #ifdef DEBUG_PPPD
-    int x;
+	int x;
 #endif
-    struct termios ptyconf;
-    char *str;
+	struct termios ptyconf;
+	char *str;
 #ifdef __uClinux__
 	struct call *sc;
 	struct tunnel *st;
 #endif
-    p = opts;
-    stropt[0] = strdup (PPPD);
-    while (p)
-    {
-        stropt[pos] = (char *) malloc (strlen (p->option) + 1);
-        strncpy (stropt[pos], p->option, strlen (p->option) + 1);
-        pos++;
-        p = p->next;
-    }
-    stropt[pos] = NULL;
-    if (c->pppd > 0)
-    {
-        log (LOG_WARN, "%s: PPP already started on call!\n", __FUNCTION__);
-        return -EINVAL;
-    }
-    if (c->fd > -1)
-    {
-        log (LOG_WARN, "%s: file descriptor already assigned!\n",
-             __FUNCTION__);
-        return -EINVAL;
-    }
+	dbg(">>%s()\n", __FUNCTION__);	//eric++
+	p = opts;
+	stropt[0] = strdup(PPPD);
+	while (p)
+	{
+		stropt[pos] = (char *) malloc(strlen(p->option) + 1);
+		strncpy(stropt[pos], p->option, strlen(p->option) + 1);
+		pos++;
+		p = p->next;
+	}
+	stropt[pos] = NULL;
+	if (c->pppd > 0)
+	{
+		log(LOG_WARN, "%s: PPP already started on call!\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	if (c->fd > -1)
+	{
+		log(LOG_WARN, "%s: file descriptor already assigned!\n", __FUNCTION__);
+		return -EINVAL;
+	}
 #ifdef USE_KERNEL
-    if (kernel_support)
-    {
-        co.ourtid = c->container->ourtid;
-        co.ourcid = c->ourcid;
-        ioctl (server_socket, L2TPIOCGETCALLOPTS, &co);
-        stropt[pos++] = strdup ("channel");
-        stropt[pos] = (char *) malloc (10);
-        snprintf (stropt[pos], 10, "%d", co.id);
-        pos++;
-        stropt[pos] = NULL;
-    }
-    else
-    {
-#endif
-        if ((c->fd = getPtyMaster (&a, &b)) < 0)
-        {
-            log (LOG_WARN, "%s: unable to allocate pty, abandoning!\n",
-                 __FUNCTION__);
-            return -EINVAL;
-        }
-
-        /* set fd opened above to not echo so we don't see read our own packets
-           back of the file descriptor that we just wrote them to */
-        tcgetattr (c->fd, &ptyconf);
-        *(c->oldptyconf) = ptyconf;
-        ptyconf.c_cflag &= ~(ICANON | ECHO);
-        ptyconf.c_lflag &= ~ECHO;
-        tcsetattr (c->fd, TCSANOW, &ptyconf);
+	if (kernel_support)
+	{
+		co.ourtid = c->container->ourtid;
+		co.ourcid = c->ourcid;
+		ioctl(server_socket, L2TPIOCGETCALLOPTS, &co);
+		stropt[pos++] = strdup("channel");
+		stropt[pos] = (char *) malloc(10);
+		snprintf(stropt[pos], 10, "%d", co.id);
+		pos++;
+		stropt[pos] = NULL;
+	} else
+	{
+#endif
+		if ((c->fd = getPtyMaster(&a, &b)) < 0)
+		{
+			log(LOG_WARN, "%s: unable to allocate pty, abandoning!\n", __FUNCTION__);
+			return -EINVAL;
+		}
+
+		/* set fd opened above to not echo so we don't see read our own packets
+		   back of the file descriptor that we just wrote them to */
+		tcgetattr(c->fd, &ptyconf);
+		*(c->oldptyconf) = ptyconf;
+		ptyconf.c_cflag &= ~(ICANON | ECHO);
+		ptyconf.c_lflag &= ~ECHO;
+		tcsetattr(c->fd, TCSANOW, &ptyconf);
 
-        snprintf (tty, sizeof (tty), "/dev/tty%c%c", a, b);
-        fd2 = open (tty, O_RDWR);
+		snprintf(tty, sizeof(tty), "/dev/tty%c%c", a, b);
+		fd2 = open(tty, O_RDWR);
 		if (fd2 < 0)
-	    	log (LOG_WARN, "unable to open tty: %s ", tty);
+			log(LOG_WARN, "unable to open tty: %s ", tty);
 
 #ifdef USE_KERNEL
-    }
+	}
 #endif
-    str = stropt[0];
+	str = stropt[0];
 #ifdef DEBUG_PPPD
-    log (LOG_DEBUG, "%s: I'm running:  ", __FUNCTION__);
-    for (x = 0; stropt[x]; x++)
-    {
-        log (LOG_DEBUG, "\"%s\" ", stropt[x]);
-    };
-    log (LOG_DEBUG, "\n");
+	log(LOG_DEBUG, "%s: I'm running:  ", __FUNCTION__);
+	for (x = 0; stropt[x]; x++)
+	{
+		log(LOG_DEBUG, "\"%s\" ", stropt[x]);
+	};
+	log(LOG_DEBUG, "\n");
 #endif
 #ifdef __uClinux__
-    c->pppd = vfork ();
-#else 
-    c->pppd = vfork ();
-#endif
-    if (c->pppd < 0)
-    {
-        log (LOG_WARN, "%s: unable to fork(), abandoning!\n", __FUNCTION__);
-        return -EINVAL;
-    }
-    else if (!c->pppd)
-    {
+	c->pppd = vfork();
+#else
+	c->pppd = vfork();
+#endif
+	if (c->pppd < 0)
+	{
+		log(LOG_WARN, "%s: unable to fork(), abandoning!\n", __FUNCTION__);
+		return -EINVAL;
+	} else if (!c->pppd)
+	{
 #ifndef __uClinux__
-        struct call *sc;
-        struct tunnel *st;
+		struct call *sc;
+		struct tunnel *st;
 #endif
 
-        close (0);
-       	close (1);
-        close (2);
+		dbg("%s(): child process\n", __FUNCTION__);	//eric++
+		close(0);
+		close(1);
+		close(2);
 #ifdef USE_KERNEL
-        if (!kernel_support && (fd2 < 0))
+		if (!kernel_support && (fd2 < 0))
 #else
-        if (fd2 < 0)
+		if (fd2 < 0)
 #endif
-        {
-            log (LOG_WARN, "%s: Unable to open %s to launch pppd!\n",
-                 __FUNCTION__, tty);
+		{
+			log(LOG_WARN, "%s: Unable to open %s to launch pppd!\n", __FUNCTION__, tty);
 #ifdef __uClinux__
-            _exit (1);
+			_exit(1);
 #else
-            exit (1);
+			exit(1);
 #endif
-        }
-        dup2 (fd2, 0);
-        dup2 (fd2, 1);
-
-
-        /* close all the calls pty fds */
-        st = tunnels.head;
-        while (st)
-        {
-            sc = st->call_head;
-            while (sc)
-            {
-                close (sc->fd);
-                sc = sc->next;
-            }
-            st = st->next;
-        }
+		}
+		dup2(fd2, 0);
+		dup2(fd2, 1);
+
+
+		/* close all the calls pty fds */
+		st = tunnels.head;
+		while (st)
+		{
+			sc = st->call_head;
+			while (sc)
+			{
+				close(sc->fd);
+				sc = sc->next;
+			}
+			st = st->next;
+		}
 
-        /* close the UDP socket fd */
-        close (server_socket);
+		/* close the UDP socket fd */
+		close(server_socket);
 
-        /* close the control pipe fd */
-        close (control_fd);
+		/* close the control pipe fd */
+		close(control_fd);
 
-        execv (PPPD, stropt);
-        log (LOG_WARN, "%s: Exec of %s failed!\n", __FUNCTION__, PPPD);
+		execv(PPPD, stropt);
+		log(LOG_WARN, "%s: Exec of %s failed!\n", __FUNCTION__, PPPD);
 #ifndef __uClinux__
-        _exit (1);
+		_exit(1);
 #else
-        exit (1);
+		exit(1);
 #endif
-    }
-    close (fd2);
-    pos = 0;
-    while (stropt[pos])
-    {
-        free (stropt[pos]);
-        pos++;
-    };
-    return 0;
-}
-
-void destroy_tunnel (struct tunnel *t)
-{
-    /*
-     * Immediately destroy a tunnel (and all its calls)
-     * and free its resources.  This may be called
-     * by the tunnel itself,so it needs to be
-     * "suicide safe"
-     */
-
-    struct call *c, *me;
-    struct tunnel *p;
-    struct timeval tv;
-    if (!t)
-        return;
-
-    /*
-     * Save ourselves until the very
-     * end, since we might be calling this ourselves.
-     * We must divorce ourself from the tunnel
-     * structure, however, to avoid recursion
-     * because of the logic of the destroy_call
-     */
-    me = t->self;
-
-    /*
-     * Destroy all the member calls
-     */
-    c = t->call_head;
-    while (c)
-    {
-        destroy_call (c);
-        c = c->next;
-    };
-    /*
-     * Remove ourselves from the list of tunnels
-     */
-
-    if (tunnels.head == t)
-    {
-        tunnels.head = t->next;
-        tunnels.count--;
-    }
-    else
-    {
-        p = tunnels.head;
-        if (p)
-        {
-            while (p->next && (p->next != t))
-                p = p->next;
-            if (p->next)
-            {
-                p->next = t->next;
-                tunnels.count--;
-            }
-            else
-            {
-                log (LOG_WARN,
-                     "%s: unable to locate tunnel in tunnel list\n",
-                     __FUNCTION__);
-            }
-        }
-        else
-        {
-            log (LOG_WARN, "%s: tunnel list is empty!\n", __FUNCTION__);
-        }
-    }
-    if (t->lac)
-    {
-        t->lac->t = NULL;
-        if (t->lac->redial && (t->lac->rtimeout > 0) && !t->lac->rsched &&
-            t->lac->active)
-        {
-            log (LOG_LOG, "Will redial in %d seconds\n", 
-                 t->lac->rtimeout);
-            tv.tv_sec = t->lac->rtimeout;
-            tv.tv_usec = 0;
-            t->lac->rsched = schedule (tv, magic_lac_dial, t->lac);
-        }
-    }
-    /* XXX L2TP/IPSec: remove relevant SAs here?  NTB 20011010
-     * XXX But what if another tunnel is using same SA?
-     */
-    if (t->lns)
-        t->lns->t = NULL;
-    free (t);
-    free (me);
-}
-
-struct tunnel *l2tp_call (char *host, int port, struct lac *lac,
-                          struct lns *lns)
-{
-    /*
-     * Establish a tunnel from us to host
-     * on port port
-     */
-    struct call *tmp = NULL;
-    struct hostent *hp;
-    unsigned int addr;
-    port = htons (port);
-    hp = gethostbyname (host);
-    if (!hp)
-    {
-        log (LOG_WARN, "Host name lookup failed for %s.\n",
-             host);
-        return NULL;
-    }
-    bcopy (hp->h_addr, &addr, hp->h_length);
-    /* Force creation of a new tunnel
-       and set it's tid to 0 to cause
-       negotiation to occur */
-    /* XXX L2TP/IPSec: Set up SA to addr:port here?  NTB 20011010
-     */
-    tmp = get_call (0, 0, addr, port);
-    if (!tmp)
-    {
-        log (LOG_WARN, "%s: Unable to create tunnel to %s.\n", __FUNCTION__,
-             host);
-        return NULL;
-    }
-    tmp->container->tid = 0;
-    tmp->container->lac = lac;
-    tmp->container->lns = lns;
-    tmp->lac = lac;
-    tmp->lns = lns;
-    if (lac)
-        lac->t = tmp->container;
-    if (lns)
-        lns->t = tmp->container;
-    /*
-     * Since our state is 0, we will establish a tunnel now
-     */
-    log (LOG_NOTICE, "Connecting to host %s, port %d\n", host,
-         ntohs (port));
-    control_finish (tmp->container, tmp);
-    return tmp->container;
-}
-
-void magic_lac_tunnel (void *data)
-{
-    struct lac *lac;
-    lac = (struct lac *) data;
-    if (!lac)
-    {
-        log (LOG_WARN, "%s: magic_lac_tunnel: called on NULL lac!\n",
-             __FUNCTION__);
-        return;
-    }
-    if (lac->lns)
-    {
-        /* FIXME: I should try different LNS's if I get failures */
-        l2tp_call (lac->lns->hostname, lac->lns->port, lac, NULL);
-        return;
-    }
-    else if (deflac && deflac->lns)
-    {
-        l2tp_call (deflac->lns->hostname, deflac->lns->port, lac, NULL);
-        return;
-    }
-    else
-    {
-        log (LOG_WARN, "%s: Unable to find hostname to dial for '%s'\n",
-             __FUNCTION__, lac->entname);
-        return;
-    }
-}
-
-struct call *lac_call (int tid, struct lac *lac, struct lns *lns)
-{
-    struct tunnel *t = tunnels.head;
-    struct call *tmp;
-    while (t)
-    {
-        if (t->ourtid == tid)
-        {
-            tmp = new_call (t);
-            if (!tmp)
-            {
-                log (LOG_WARN, "%s: unable to create new call\n",
-                     __FUNCTION__);
-                return NULL;
-            }
-            tmp->next = t->call_head;
-            t->call_head = tmp;
-            t->count++;
-            tmp->cid = 0;
-            tmp->lac = lac;
-            tmp->lns = lns;
-            if (lac)
-                lac->c = tmp;
-            log (LOG_NOTICE, "Calling on tunnel %d\n", tid);
-            strcpy (tmp->dial_no, dial_no_tmp); /*  jz: copy dialnumber to tmp->dial_no  */
-	    log (LOG_NOTICE, "Debug msg:: The msgtype send to control finish is %d\n", tmp->msgtype);
-            control_finish (t, tmp);
-            return tmp;
-        }
-        t = t->next;
-    };
-    log (LOG_DEBUG, "%s: No such tunnel %d to generate call.\n", __FUNCTION__,
-         tid);
-    return NULL;
-}
-
-void magic_lac_dial (void *data)
-{
-    struct lac *lac;
-    lac = (struct lac *) data;
-    if (!lac->active)
-    {
-        log (LOG_DEBUG, "%s: LAC %s not active", __FUNCTION__, lac->entname);
-        return;
-    }
-    lac->rsched = NULL;
-    lac->rtries++;
-    if (lac->rmax && (lac->rtries > lac->rmax))
-    {
-        log (LOG_LOG, "%s: maximum retries exceeded.\n", __FUNCTION__);
-        return;
-    }
-    if (!lac)
-    {
-        log (LOG_WARN, "%s : called on NULL lac!\n", __FUNCTION__);
-        return;
-    }
-    if (!lac->t)
-    {
+	}
+	close(fd2);
+	pos = 0;
+	while (stropt[pos])
+	{
+		free(stropt[pos]);
+		pos++;
+	};
+	dbg("<< %s()\n", __FUNCTION__);	//eric++
+	return 0;
+}
+
+void destroy_tunnel(struct tunnel *t)
+{
+	/*
+	 * Immediately destroy a tunnel (and all its calls)
+	 * and free its resources.  This may be called
+	 * by the tunnel itself,so it needs to be
+	 * "suicide safe"
+	 */
+
+	struct call *c, *me;
+	struct tunnel *p;
+	struct timeval tv;
+	if (!t)
+		return;
+
+	/*
+	 * Save ourselves until the very
+	 * end, since we might be calling this ourselves.
+	 * We must divorce ourself from the tunnel
+	 * structure, however, to avoid recursion
+	 * because of the logic of the destroy_call
+	 */
+	me = t->self;
+
+	/*
+	 * Destroy all the member calls
+	 */
+	c = t->call_head;
+	while (c)
+	{
+		destroy_call(c);
+		c = c->next;
+	};
+	/*
+	 * Remove ourselves from the list of tunnels
+	 */
+
+	if (tunnels.head == t)
+	{
+		tunnels.head = t->next;
+		tunnels.count--;
+	} else
+	{
+		p = tunnels.head;
+		if (p)
+		{
+			while (p->next && (p->next != t))
+				p = p->next;
+			if (p->next)
+			{
+				p->next = t->next;
+				tunnels.count--;
+			} else
+			{
+				log(LOG_WARN, "%s: unable to locate tunnel in tunnel list\n", __FUNCTION__);
+			}
+		} else
+		{
+			log(LOG_WARN, "%s: tunnel list is empty!\n", __FUNCTION__);
+		}
+	}
+	if (t->lac)
+	{
+		t->lac->t = NULL;
+		if (t->lac->redial && (t->lac->rtimeout > 0) && !t->lac->rsched && t->lac->active)
+		{
+			log(LOG_LOG, "Will redial in %d seconds\n", t->lac->rtimeout);
+			tv.tv_sec = t->lac->rtimeout;
+			tv.tv_usec = 0;
+			t->lac->rsched = schedule(tv, magic_lac_dial, t->lac);
+		}
+	}
+	/* XXX L2TP/IPSec: remove relevant SAs here?  NTB 20011010
+	 * XXX But what if another tunnel is using same SA?
+	 */
+	if (t->lns)
+		t->lns->t = NULL;
+	free(t);
+	free(me);
+}
+
+struct tunnel *l2tp_call(char *host, int port, struct lac *lac, struct lns *lns)
+{
+	/*
+	 * Establish a tunnel from us to host
+	 * on port port
+	 */
+	struct call *tmp = NULL;
+	struct hostent *hp;
+	unsigned int addr;
+	port = htons(port);
+	hp = gethostbyname(host);
+	if (!hp)
+	{
+		log(LOG_WARN, "Host name lookup failed for %s.\n", host);
+		return NULL;
+	}
+	bcopy(hp->h_addr, &addr, hp->h_length);
+	/* Force creation of a new tunnel
+	   and set it's tid to 0 to cause
+	   negotiation to occur */
+	/* XXX L2TP/IPSec: Set up SA to addr:port here?  NTB 20011010
+	 */
+	tmp = get_call(0, 0, addr, port);
+	if (!tmp)
+	{
+		log(LOG_WARN, "%s: Unable to create tunnel to %s.\n", __FUNCTION__, host);
+		return NULL;
+	}
+	tmp->container->tid = 0;
+	tmp->container->lac = lac;
+	tmp->container->lns = lns;
+	tmp->lac = lac;
+	tmp->lns = lns;
+	if (lac)
+		lac->t = tmp->container;
+	if (lns)
+		lns->t = tmp->container;
+	/*
+	 * Since our state is 0, we will establish a tunnel now
+	 */
+	log(LOG_NOTICE, "Connecting to host %s, port %d\n", host, ntohs(port));
+	control_finish(tmp->container, tmp);
+	return tmp->container;
+}
+
+void magic_lac_tunnel(void *data)
+{
+	struct lac *lac;
+	lac = (struct lac *) data;
+	if (!lac)
+	{
+		log(LOG_WARN, "%s: magic_lac_tunnel: called on NULL lac!\n", __FUNCTION__);
+		return;
+	}
+	if (lac->lns)
+	{
+		/* FIXME: I should try different LNS's if I get failures */
+		l2tp_call(lac->lns->hostname, lac->lns->port, lac, NULL);
+		return;
+	} else if (deflac && deflac->lns)
+	{
+		l2tp_call(deflac->lns->hostname, deflac->lns->port, lac, NULL);
+		return;
+	} else
+	{
+		log(LOG_WARN, "%s: Unable to find hostname to dial for '%s'\n", __FUNCTION__, lac->entname);
+		return;
+	}
+}
+
+struct call *lac_call(int tid, struct lac *lac, struct lns *lns)
+{
+	struct tunnel *t = tunnels.head;
+	struct call *tmp;
+	while (t)
+	{
+		if (t->ourtid == tid)
+		{
+			tmp = new_call(t);
+			if (!tmp)
+			{
+				log(LOG_WARN, "%s: unable to create new call\n", __FUNCTION__);
+				return NULL;
+			}
+			tmp->next = t->call_head;
+			t->call_head = tmp;
+			t->count++;
+			tmp->cid = 0;
+			tmp->lac = lac;
+			tmp->lns = lns;
+			if (lac)
+				lac->c = tmp;
+			log(LOG_NOTICE, "Calling on tunnel %d\n", tid);
+			strcpy(tmp->dial_no, dial_no_tmp);	/*  jz: copy dialnumber to tmp->dial_no  */
+			log(LOG_NOTICE, "Debug msg:: The msgtype send to control finish is %d\n", tmp->msgtype);
+			control_finish(t, tmp);
+			return tmp;
+		}
+		t = t->next;
+	};
+	log(LOG_DEBUG, "%s: No such tunnel %d to generate call.\n", __FUNCTION__, tid);
+	return NULL;
+}
+
+void magic_lac_dial(void *data)
+{
+	struct lac *lac;
+	lac = (struct lac *) data;
+	if (!lac->active)
+	{
+		log(LOG_DEBUG, "%s: LAC %s not active", __FUNCTION__, lac->entname);
+		return;
+	}
+	lac->rsched = NULL;
+	lac->rtries++;
+	if (lac->rmax && (lac->rtries > lac->rmax))
+	{
+		log(LOG_LOG, "%s: maximum retries exceeded.\n", __FUNCTION__);
+		return;
+	}
+	if (!lac)
+	{
+		log(LOG_WARN, "%s : called on NULL lac!\n", __FUNCTION__);
+		return;
+	}
+	if (!lac->t)
+	{
 #ifdef DEGUG_MAGIC
-        log (LOG_DEBUG, "%s : tunnel not up!  Connecting!\n", __FUNCTION__);
+		log(LOG_DEBUG, "%s : tunnel not up!  Connecting!\n", __FUNCTION__);
 #endif
-        magic_lac_tunnel (lac);
-        return;
-    }
-    lac_call (lac->t->ourtid, lac, NULL);
-}
-
-void lac_hangup (int cid)
-{
-    struct tunnel *t = tunnels.head;
-    struct call *tmp;
-    while (t)
-    {
-        tmp = t->call_head;
-        while (tmp)
-        {
-            if (tmp->ourcid == cid)
-            {
-                log (LOG_LOG,
-                     "%s :Hanging up call %d, Local: %d, Remote: %d\n",
-                     __FUNCTION__, tmp->serno, tmp->ourcid, tmp->cid);
-                strcpy (tmp->errormsg, "Goodbye!");
+		magic_lac_tunnel(lac);
+		return;
+	}
+	lac_call(lac->t->ourtid, lac, NULL);
+}
+
+void lac_hangup(int cid)
+{
+	struct tunnel *t = tunnels.head;
+	struct call *tmp;
+	while (t)
+	{
+		tmp = t->call_head;
+		while (tmp)
+		{
+			if (tmp->ourcid == cid)
+			{
+				log(LOG_LOG, "%s :Hanging up call %d, Local: %d, Remote: %d\n", __FUNCTION__, tmp->serno, tmp->ourcid, tmp->cid);
+				strcpy(tmp->errormsg, "Goodbye!");
 /*				tmp->needclose = -1; */
-                kill (tmp->pppd, SIGTERM);
-                return;
-            }
-            tmp = tmp->next;
-        }
-        t = t->next;
-    };
-    log (LOG_DEBUG, "%s : No such call %d to hang up.\n", __FUNCTION__, cid);
-    return;
-}
-
-void lac_disconnect (int tid)
-{
-    struct tunnel *t = tunnels.head;
-    while (t)
-    {
-        if (t->ourtid == tid)
-        {
-            log (LOG_LOG,
-                 "Disconnecting from %s, Local: %d, Remote: %d\n",
-                 IPADDY (t->peer.sin_addr), t->ourtid, t->tid);
-            t->self->needclose = -1;
-            strcpy (t->self->errormsg, "Goodbye!");
-            call_close (t->self);
-            return;
-        }
-        t = t->next;
-    };
-    log (LOG_DEBUG, "No such tunnel %d to hang up.\n", tid);
-    return;
-}
-
-struct tunnel *new_tunnel ()
-{
-    struct tunnel *tmp = malloc (sizeof (struct tunnel));
-    char entropy_buf[2] = "\0";
-    if (!tmp)
-        return NULL;
-    tmp->control_seq_num = 0;
-    tmp->control_rec_seq_num = 0;
-    tmp->cLr = 0;
-    tmp->call_head = NULL;
-    tmp->next = NULL;
-    tmp->debug = -1;
-    tmp->tid = -1;
-    tmp->hello = NULL;
+				dbg ("%s(): send SITERM to pid %d\n", __FUNCTION__, tmp->pppd); //eric++
+				kill(tmp->pppd, SIGTERM);
+				return;
+			}
+			tmp = tmp->next;
+		}
+		t = t->next;
+	};
+	log(LOG_DEBUG, "%s : No such call %d to hang up.\n", __FUNCTION__, cid);
+	return;
+}
+
+void lac_disconnect(int tid)
+{
+	struct tunnel *t = tunnels.head;
+	while (t)
+	{
+		if (t->ourtid == tid)
+		{
+			log(LOG_LOG, "Disconnecting from %s, Local: %d, Remote: %d\n", IPADDY(t->peer.sin_addr), t->ourtid, t->tid);
+			t->self->needclose = -1;
+			strcpy(t->self->errormsg, "Goodbye!");
+			call_close(t->self);
+			return;
+		}
+		t = t->next;
+	};
+	log(LOG_DEBUG, "No such tunnel %d to hang up.\n", tid);
+	return;
+}
+
+struct tunnel *new_tunnel()
+{
+	struct tunnel *tmp = malloc(sizeof(struct tunnel));
+	char entropy_buf[2] = "\0";
+	if (!tmp)
+		return NULL;
+	tmp->control_seq_num = 0;
+	tmp->control_rec_seq_num = 0;
+	tmp->cLr = 0;
+	tmp->call_head = NULL;
+	tmp->next = NULL;
+	tmp->debug = -1;
+	tmp->tid = -1;
+	tmp->hello = NULL;
 #ifndef TESTING
 /*	while(get_call((tmp->ourtid = rand() & 0xFFFF),0,0,0)); */
 #ifdef USE_KERNEL
-    if (kernel_support)
-        tmp->ourtid = ioctl (server_socket, L2TPIOCADDTUNNEL, 0);
-    else
+	if (kernel_support)
+		tmp->ourtid = ioctl(server_socket, L2TPIOCADDTUNNEL, 0);
+	else
 #endif
 /*        tmp->ourtid = rand () & 0xFFFF; */
-        /* get_entropy((char *)&tmp->ourtid, 2); */
-        get_entropy(entropy_buf, 2);
-        {
-            unsigned short *temp;
-            temp = (unsigned short *)entropy_buf;
-            tmp->ourtid = *temp & 0xFFFF;
+		/* get_entropy((char *)&tmp->ourtid, 2); */
+		get_entropy(entropy_buf, 2);
+	{
+		unsigned short *temp;
+		temp = (unsigned short *) entropy_buf;
+		tmp->ourtid = *temp & 0xFFFF;
 #ifdef DEBUG_ENTROPY
-            log(LOG_DEBUG, "ourtid = %u, entropy_buf = %hx\n", tmp->ourtid, *temp);
+		log(LOG_DEBUG, "ourtid = %u, entropy_buf = %hx\n", tmp->ourtid, *temp);
 #endif
-        }
+	}
 
 #else
-    tmp->ourtid = 0x6227;
+	tmp->ourtid = 0x6227;
 #endif
-    tmp->nego = 0;
-    tmp->count = 0;
-    tmp->state = 0;             /* Nothing */
-    tmp->peer.sin_family = AF_INET;
-    tmp->peer.sin_port = 0;
-    bzero (&(tmp->peer.sin_addr), sizeof (tmp->peer.sin_addr));
-    tmp->sanity = -1;
-    tmp->qtid = -1;
-    tmp->ourfc = ASYNC_FRAMING | SYNC_FRAMING;
-    tmp->ourbc = 0;
-    tmp->ourtb = (((_u64) rand ()) << 32) | ((_u64) rand ());
-    tmp->fc = -1;               /* These really need to be specified by the peer */
-    tmp->bc = -1;               /* And we want to know if they forgot */
-    tmp->hostname[0] = 0;
-    tmp->vendor[0] = 0;
-    tmp->secret[0] = 0;
-    if (!(tmp->self = new_call (tmp)))
-    {
-        free (tmp);
-        return NULL;
-    };
-    tmp->ourrws = DEFAULT_RWS_SIZE;
-    tmp->self->ourfbit = FBIT;
-    tmp->lac = NULL;
-    tmp->lns = NULL;
-    tmp->chal_us.state = 0;
-    tmp->chal_us.secret[0] = 0;
-    memset (tmp->chal_us.reply, 0, MD_SIG_SIZE);
-    tmp->chal_them.state = 0;
-    tmp->chal_them.secret[0] = 0;
-    memset (tmp->chal_them.reply, 0, MD_SIG_SIZE);
-    tmp->chal_them.vector = (unsigned char *) malloc (VECTOR_SIZE);
-    tmp->chal_us.vector = NULL;
-    tmp->hbit = 0;
-    return tmp;
-}
-
-void do_control ()
-{
-    char buf[1024];
-    char *host;
-    char *tunstr;
-    char *callstr;
-
-    char *sub_str;              /* jz: use by the strtok function */
-    char *tmp_ptr;              /* jz: use by the strtok function */
-    struct lac *lac;
-    int call;
-    int tunl;
-    int cnt = -1;
-
-    while (cnt)
-    {
-//	log (LOG_DEBUG, "Debug MSG:::The cnt loop is active!!\n");
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-	{
-		log (LOG_DEBUG, "Debug MSG::: The lns_server_name is '%s' at l2tpd.c!!\n", lns_server_name);
-		log (LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' at l2tpd.c!!\n",strlen(lns_server_name));
-		strcpy(buf, lns_server_name);
-		cnt = strlen(lns_server_name);
-		log (LOG_DEBUG, "Debug MSG::: The cnt is '%s' at l2tpd.c\n", cnt);
-		lns_server_name[0]=0x0;
-		log (LOG_DEBUG, "Debug MSG::: The lns_server_name should be zero, but it is '%s'!\n", lns_server_name);
-		log (LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' after setting zero!!\n", strlen(lns_server_name));
-	}
-	else cnt = read (control_fd, buf, sizeof (buf));
-        if (cnt > 0)
-        {
-		if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
-                log (LOG_DEBUG, "Debug msg:: before if(buf[cnt - 1] ==)@l2tpd.c\n");
-        }
-            if (buf[cnt - 1] == '\n')
-                buf[--cnt] = 0;
+	tmp->nego = 0;
+	tmp->count = 0;
+	tmp->state = 0;				/* Nothing */
+	tmp->peer.sin_family = AF_INET;
+	tmp->peer.sin_port = 0;
+	bzero(&(tmp->peer.sin_addr), sizeof(tmp->peer.sin_addr));
+	tmp->sanity = -1;
+	tmp->qtid = -1;
+	tmp->ourfc = ASYNC_FRAMING | SYNC_FRAMING;
+	tmp->ourbc = 0;
+	tmp->ourtb = (((_u64) rand()) << 32) | ((_u64) rand());
+	tmp->fc = -1;				/* These really need to be specified by the peer */
+	tmp->bc = -1;				/* And we want to know if they forgot */
+	tmp->hostname[0] = 0;
+	tmp->vendor[0] = 0;
+	tmp->secret[0] = 0;
+	if (!(tmp->self = new_call(tmp)))
+	{
+		free(tmp);
+		return NULL;
+	};
+	tmp->ourrws = DEFAULT_RWS_SIZE;
+	tmp->self->ourfbit = FBIT;
+	tmp->lac = NULL;
+	tmp->lns = NULL;
+	tmp->chal_us.state = 0;
+	tmp->chal_us.secret[0] = 0;
+	memset(tmp->chal_us.reply, 0, MD_SIG_SIZE);
+	tmp->chal_them.state = 0;
+	tmp->chal_them.secret[0] = 0;
+	memset(tmp->chal_them.reply, 0, MD_SIG_SIZE);
+	tmp->chal_them.vector = (unsigned char *) malloc(VECTOR_SIZE);
+	tmp->chal_us.vector = NULL;
+	tmp->hbit = 0;
+	return tmp;
+}
+
+void do_control()
+{
+	char buf[1024];
+	char *host;
+	char *tunstr;
+	char *callstr;
+
+	char *sub_str;				/* jz: use by the strtok function */
+	char *tmp_ptr;				/* jz: use by the strtok function */
+	struct lac *lac;
+	int call;
+	int tunl;
+	int cnt = -1;
+
+	while (cnt)
+	{
+//  log (LOG_DEBUG, "Debug MSG:::The cnt loop is active!!\n");
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
+			log(LOG_DEBUG, "Debug MSG::: The lns_server_name is '%s' at l2tpd.c!!\n", lns_server_name);
+			log(LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' at l2tpd.c!!\n", strlen(lns_server_name));
+			strcpy(buf, lns_server_name);
+			cnt = strlen(lns_server_name);
+			log(LOG_DEBUG, "Debug MSG::: The cnt is '%s' at l2tpd.c\n", cnt);
+			lns_server_name[0] = 0x0;
+			log(LOG_DEBUG, "Debug MSG::: The lns_server_name should be zero, but it is '%s'!\n", lns_server_name);
+			log(LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' after setting zero!!\n", strlen(lns_server_name));
+		} else
+			cnt = read(control_fd, buf, sizeof(buf));
+		if (cnt > 0)
+		{
+			if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+			{
+				log(LOG_DEBUG, "Debug msg:: before if(buf[cnt - 1] ==)@l2tpd.c\n");
+			}
+			if (buf[cnt - 1] == '\n')
+				buf[--cnt] = 0;
 #ifdef DEBUG_CONTROL
-            log (LOG_DEBUG, "%s: Got message %s (%d bytes long)\n",
-                 __FUNCTION__, buf, cnt);
+			log(LOG_DEBUG, "%s: Got message %s (%d bytes long)\n", __FUNCTION__, buf, cnt);
 #endif
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
-                log (LOG_DEBUG, "Debug msg:: before switch (buf[0])@l2tpd.c\n");
-        }
-            switch (buf[0])
-            {
-            case 't':
-                host = strchr (buf, ' ') + 1;
+			if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+			{
+				log(LOG_DEBUG, "Debug msg:: before switch (buf[0])@l2tpd.c\n");
+			}
+			switch (buf[0])
+			{
+			case 't':
+				host = strchr(buf, ' ') + 1;
 #ifdef DEBUG_CONTROL
-                log (LOG_DEBUG, "%s: Attempting to tunnel to %s\n",
-                     __FUNCTION__, host);
+				log(LOG_DEBUG, "%s: Attempting to tunnel to %s\n", __FUNCTION__, host);
 #endif
-                l2tp_call (host, UDP_LISTEN_PORT, NULL, NULL);
-                break;
-            case 'c':
-
-     	           log (LOG_DEBUG, "Debug msg:: before switch_io=1@l2tpd.c\n");
-                switch_io = 1;  /* jz: Switch for Incoming - Outgoing Calls */
-
-        	        log (LOG_DEBUG, "Debug msg:: before tunstr = ...@l2tpd.c\n");
-                tunstr = strchr (buf, ' ') + 1;
-			log (LOG_DEBUG, "Debug msg:: before tunstr = %s@l2tpd.c\n", tunstr);
-                	log (LOG_DEBUG, "Debug msg:: before lac = laclist@l2tpd.c\n");
-                lac = laclist;
-	                log (LOG_DEBUG, "Debug msg:: before while(lac)@l2tpd.c\n");
-                while (lac)
-                {
-         	       log (LOG_DEBUG, "Debug msg:: before if(!strcasecmp(lac->...))@l2tpd.c\n");
-                    if (!strcasecmp (lac->entname, tunstr))
-                    {
-                		log (LOG_DEBUG, "Debug msg:: before lac->active@l2tpd.c\n");
-                        lac->active = -1;
-		                log (LOG_DEBUG, "Debug msg:: before lac->retries@l2tpd.c\n");
-                        lac->rtries = 0;
-	        	        log (LOG_DEBUG, "Debug msg:: before if(!lac->c)@l2tpd.c\n");
-                        if (!lac->c){
-                		log (LOG_DEBUG, "Debug msg:: before magic_lac_dial(lac)@l2tpd.c\n");
-                            magic_lac_dial (lac);}
-                        else
-                            log (LOG_DEBUG,
-                                 "Session '%s' already active!\n", lac->entname);
-                        break;
-                    }
-                    lac = lac->next;
-                }
-                if (lac){
-		                log (LOG_DEBUG, "Debug msg:: before @l2tpd.c\n");
-                    break;
-		}
-                tunl = atoi (tunstr);
-		log (LOG_DEBUG, "Debug msg::  The tunnel is  %d@l2tpd.c\n", tunl);
-		
-                if (!tunl)
-                {
-                    log (LOG_DEBUG, "No such tunnel '%s'\n", tunstr);
-                    break;
-                }
+				l2tp_call(host, UDP_LISTEN_PORT, NULL, NULL);
+				break;
+			case 'c':
+
+				log(LOG_DEBUG, "Debug msg:: before switch_io=1@l2tpd.c\n");
+				switch_io = 1;	/* jz: Switch for Incoming - Outgoing Calls */
+
+				log(LOG_DEBUG, "Debug msg:: before tunstr = ...@l2tpd.c\n");
+				tunstr = strchr(buf, ' ') + 1;
+				log(LOG_DEBUG, "Debug msg:: before tunstr = %s@l2tpd.c\n", tunstr);
+				log(LOG_DEBUG, "Debug msg:: before lac = laclist@l2tpd.c\n");
+				lac = laclist;
+				log(LOG_DEBUG, "Debug msg:: before while(lac)@l2tpd.c\n");
+				while (lac)
+				{
+					log(LOG_DEBUG, "Debug msg:: before if(!strcasecmp(lac->...))@l2tpd.c\n");
+					if (!strcasecmp(lac->entname, tunstr))
+					{
+						log(LOG_DEBUG, "Debug msg:: before lac->active@l2tpd.c\n");
+						lac->active = -1;
+						log(LOG_DEBUG, "Debug msg:: before lac->retries@l2tpd.c\n");
+						lac->rtries = 0;
+						log(LOG_DEBUG, "Debug msg:: before if(!lac->c)@l2tpd.c\n");
+						if (!lac->c)
+						{
+							log(LOG_DEBUG, "Debug msg:: before magic_lac_dial(lac)@l2tpd.c\n");
+							magic_lac_dial(lac);
+						} else
+							log(LOG_DEBUG, "Session '%s' already active!\n", lac->entname);
+						break;
+					}
+					lac = lac->next;
+				}
+				if (lac)
+				{
+					log(LOG_DEBUG, "Debug msg:: before @l2tpd.c\n");
+					break;
+				}
+				tunl = atoi(tunstr);
+				log(LOG_DEBUG, "Debug msg::  The tunnel is  %d@l2tpd.c\n", tunl);
+
+				if (!tunl)
+				{
+					log(LOG_DEBUG, "No such tunnel '%s'\n", tunstr);
+					break;
+				}
 #ifdef DEBUG_CONTROL
-                log (LOG_DEBUG, "%s: Attempting to call on tunnel %d\n",
-                     __FUNCTION__, tunl);
+				log(LOG_DEBUG, "%s: Attempting to call on tunnel %d\n", __FUNCTION__, tunl);
 #endif
-                lac_call (tunl, NULL, NULL);
-                break;
+				lac_call(tunl, NULL, NULL);
+				break;
+
+			case 'o':			/* jz: option 'o' for doing a outgoing call */
 
-            case 'o':          /* jz: option 'o' for doing a outgoing call */
+				switch_io = 0;	/* jz: Switch for incoming - outgoing Calls */
 
-                switch_io = 0;  /* jz: Switch for incoming - outgoing Calls */
-
-                sub_str = strchr (buf, ' ') + 1;
-
-                tunstr = strtok (sub_str, " "); /* jz: using strtok function to get */
-                tmp_ptr = strtok (NULL, " ");   /*     params out of the pipe       */
-                strcpy (dial_no_tmp, tmp_ptr);
-
-                lac = laclist;
-                while (lac)
-                {
-                    if (!strcasecmp (lac->entname, tunstr))
-                    {
-                        lac->active = -1;
-                        lac->rtries = 0;
-                        if (!lac->c)
-                            magic_lac_dial (lac);
-                        else
-                            log (LOG_DEBUG,
-                                 "Session '%s' already active!\n",
-                                lac->entname);
-                        break;
-                    }
-                    lac = lac->next;
-                }
-                if (lac)
-                    break;
-                tunl = atoi (tunstr);
-                if (!tunl)
-                {
-                    log (LOG_DEBUG, "No such tunnel '%s'\n", tunstr);
-                    break;
-                }
+				sub_str = strchr(buf, ' ') + 1;
+
+				tunstr = strtok(sub_str, " ");	/* jz: using strtok function to get */
+				tmp_ptr = strtok(NULL, " ");	/*     params out of the pipe       */
+				strcpy(dial_no_tmp, tmp_ptr);
+
+				lac = laclist;
+				while (lac)
+				{
+					if (!strcasecmp(lac->entname, tunstr))
+					{
+						lac->active = -1;
+						lac->rtries = 0;
+						if (!lac->c)
+							magic_lac_dial(lac);
+						else
+							log(LOG_DEBUG, "Session '%s' already active!\n", lac->entname);
+						break;
+					}
+					lac = lac->next;
+				}
+				if (lac)
+					break;
+				tunl = atoi(tunstr);
+				if (!tunl)
+				{
+					log(LOG_DEBUG, "No such tunnel '%s'\n", tunstr);
+					break;
+				}
 #ifdef DEBUG_CONTROL
-                log (LOG_DEBUG, "%s: Attempting to call on tunnel %d\n",
-                     __FUNCTION__, tunl);
+				log(LOG_DEBUG, "%s: Attempting to call on tunnel %d\n", __FUNCTION__, tunl);
 #endif
-                lac_call (tunl, NULL, NULL);
-                break;
+				lac_call(tunl, NULL, NULL);
+				break;
 
-            case 'h':
-                callstr = strchr (buf, ' ') + 1;
-                call = atoi (callstr);
+			case 'h':
+				callstr = strchr(buf, ' ') + 1;
+				call = atoi(callstr);
 #ifdef DEBUG_CONTROL
-                log (LOG_DEBUG, "%s: Attempting to hangup call %d\n", __FUNCTION__,
-                     call);
+				log(LOG_DEBUG, "%s: Attempting to hangup call %d\n", __FUNCTION__, call);
 #endif
-                lac_hangup (call);
-                break;
-            case 'd':
-                tunstr = strchr (buf, ' ') + 1;
-                lac = laclist;
-                while (lac)
-                {
-                    if (!strcasecmp (lac->entname, tunstr))
-                    {
-                        lac->active = 0;
-                        lac->rtries = 0;
-                        if (lac->t)
-                            lac_disconnect (lac->t->ourtid);
-                        else
-                            log (LOG_DEBUG, "Session '%s' not up\n",
-                                 lac->entname);
-                        break;
-                    }
-                    lac = lac->next;
-                }
-                if (lac)
-                    break;
-                tunl = atoi (tunstr);
-                if (!tunl)
-                {
-                    log (LOG_DEBUG, "No such tunnel '%s'\n",
-                         tunstr);
-                    break;
-                }
+				lac_hangup(call);
+				break;
+			case 'd':
+				tunstr = strchr(buf, ' ') + 1;
+				lac = laclist;
+				while (lac)
+				{
+					if (!strcasecmp(lac->entname, tunstr))
+					{
+						lac->active = 0;
+						lac->rtries = 0;
+						if (lac->t)
+							lac_disconnect(lac->t->ourtid);
+						else
+							log(LOG_DEBUG, "Session '%s' not up\n", lac->entname);
+						break;
+					}
+					lac = lac->next;
+				}
+				if (lac)
+					break;
+				tunl = atoi(tunstr);
+				if (!tunl)
+				{
+					log(LOG_DEBUG, "No such tunnel '%s'\n", tunstr);
+					break;
+				}
 #ifdef DEBUG_CONTROL
-                log (LOG_DEBUG, "%s: Attempting to disconnect tunnel %d\n",
-                     __FUNCTION__, tunl);
+				log(LOG_DEBUG, "%s: Attempting to disconnect tunnel %d\n", __FUNCTION__, tunl);
 #endif
-                lac_disconnect (tunl);
-                break;
-            case 's':
-                show_status (1);
-                break;
-            default:
-                log (LOG_DEBUG, "Unknown command %c\n", 
-                     buf[0]);
-            }
-        }
-    }
-    /* Otherwise select goes nuts */
-    close (control_fd);
-    control_fd = open (CONTROL_PIPE, O_RDONLY | O_NONBLOCK, 0600);
-    if (control_fd < 0)
-    {
-        log (LOG_CRIT, "%s: Unable to open " CONTROL_PIPE " for reading.",
-             __FUNCTION__);
-    }
-}
-
-void usage(void) {
-    printf("Usage: l2tpd -D -c [config file] -s [secret file] -p [pid file]\n");
-    printf("\n");
-    exit(1);
-}
-
-void init_args(int argc, char *argv[]) {
-    int i=0;
-    gconfig.daemon=1;
-    memset(gconfig.altauthfile,0,STRLEN);
-    memset(gconfig.altconfigfile,0,STRLEN);
-    memset(gconfig.authfile,0,STRLEN);
-    memset(gconfig.configfile,0,STRLEN);
-    memset(gconfig.pidfile,0,STRLEN);
-    strncpy(gconfig.altauthfile,ALT_DEFAULT_AUTH_FILE,
-            sizeof(gconfig.altauthfile) - 1);
-    strncpy(gconfig.altconfigfile,ALT_DEFAULT_CONFIG_FILE,
-            sizeof(gconfig.altconfigfile) - 1);
-    strncpy(gconfig.authfile,DEFAULT_AUTH_FILE,
-            sizeof(gconfig.authfile) - 1);
-    strncpy(gconfig.configfile,DEFAULT_CONFIG_FILE,
-            sizeof(gconfig.configfile) - 1);
-    strncpy(gconfig.pidfile,DEFAULT_PID_FILE,
-            sizeof(gconfig.pidfile) - 1);
-    for (i = 1; i < argc; i++) {
-        if(! strncmp(argv[i],"-c",2)) {
-            if(++i == argc)
-                usage();
-            else
-                strncpy(gconfig.configfile,argv[i],
-                        sizeof(gconfig.configfile) - 1);
-        }
-        else if (! strncmp(argv[i],"-D",2)) {
-            gconfig.daemon=0;
-        }
-        else if (! strncmp(argv[i],"-s",2)) {
-            if(++i == argc)
-                usage();
-            else
-                strncpy(gconfig.authfile,argv[i],
-                        sizeof(gconfig.authfile) - 1);
-        }
-        else if (! strncmp(argv[i],"-p",2)) {
-            if(++i == argc)
-                usage();
-            else
-                strncpy(gconfig.pidfile,argv[i],
-                        sizeof(gconfig.pidfile) - 1);
-        }
-        else {
-            usage();
-        }
-    }
-}
-
-
-void daemonize() {
-    int pid=0;
-    int i,l;
-    char buf[STRLEN];
-    int pidfilewritten=0;
+				lac_disconnect(tunl);
+				break;
+			case 's':
+				show_status(1);
+				break;
+			default:
+				log(LOG_DEBUG, "Unknown command %c\n", buf[0]);
+			}
+		}
+	}
+	/* Otherwise select goes nuts */
+	close(control_fd);
+	control_fd = open(CONTROL_PIPE, O_RDONLY | O_NONBLOCK, 0600);
+	if (control_fd < 0)
+	{
+		log(LOG_CRIT, "%s: Unable to open " CONTROL_PIPE " for reading.", __FUNCTION__);
+	}
+}
+
+void usage(void)
+{
+	printf("Usage: l2tpd -D -c [config file] -s [secret file] -p [pid file]\n");
+	printf("\n");
+	exit(1);
+}
+
+void init_args(int argc, char *argv[])
+{
+	int i = 0;
+	gconfig.daemon = 1;
+	memset(gconfig.altauthfile, 0, STRLEN);
+	memset(gconfig.altconfigfile, 0, STRLEN);
+	memset(gconfig.authfile, 0, STRLEN);
+	memset(gconfig.configfile, 0, STRLEN);
+	memset(gconfig.pidfile, 0, STRLEN);
+	strncpy(gconfig.altauthfile, ALT_DEFAULT_AUTH_FILE, sizeof(gconfig.altauthfile) - 1);
+	strncpy(gconfig.altconfigfile, ALT_DEFAULT_CONFIG_FILE, sizeof(gconfig.altconfigfile) - 1);
+	strncpy(gconfig.authfile, DEFAULT_AUTH_FILE, sizeof(gconfig.authfile) - 1);
+	strncpy(gconfig.configfile, DEFAULT_CONFIG_FILE, sizeof(gconfig.configfile) - 1);
+	strncpy(gconfig.pidfile, DEFAULT_PID_FILE, sizeof(gconfig.pidfile) - 1);
+	for (i = 1; i < argc; i++)
+	{
+		if (!strncmp(argv[i], "-c", 2))
+		{
+			if (++i == argc)
+				usage();
+			else
+				strncpy(gconfig.configfile, argv[i], sizeof(gconfig.configfile) - 1);
+		} else if (!strncmp(argv[i], "-D", 2))
+		{
+			gconfig.daemon = 0;
+		} else if (!strncmp(argv[i], "-s", 2))
+		{
+			if (++i == argc)
+				usage();
+			else
+				strncpy(gconfig.authfile, argv[i], sizeof(gconfig.authfile) - 1);
+		} else if (!strncmp(argv[i], "-p", 2))
+		{
+			if (++i == argc)
+				usage();
+			else
+				strncpy(gconfig.pidfile, argv[i], sizeof(gconfig.pidfile) - 1);
+		} else
+		{
+			usage();
+		}
+	}
+}
+
+
+void daemonize()
+{
+	int pid = 0;
+	int i, l;
+	char buf[STRLEN];
+	int pidfilewritten = 0;
+	dbg (">> %s()\n", __FUNCTION__); //eric++
 #ifndef CONFIG_SNAPGEAR
-    if((pid = vfork()) < 0) {
-        log(LOG_LOG, "%s: Unable to fork ()\n",__FUNCTION__);
-        close(server_socket);
-        exit(1);
-    }
-    else if (pid)
-        exit(0);
-
-    /* close(0); */   /* This is a hack to "fix" problems with the
-                         daemonization code...more work will be forthcoming 
-                         to do a proper fix for this */
-
-    close(1);
-    close(2);
-#endif
-
-    /* Read previous pid file. */
-    if ((i = open(gconfig.pidfile,O_RDONLY)) > 0) {
-        l=read(i,buf,sizeof(buf)-1);
-        if (i < 0) {
-            log(LOG_LOG, "%s: Unable to read pid file [%s]\n",
-                    __FUNCTION__, gconfig.pidfile);
-        }
-        buf[i] = '\0';
-        pid = atoi(buf);
-
-        /* If the previous server process is not still running,
-           write a new pid file immediately. */
-        if (pid && (pid == getpid () || kill (pid, 0) < 0)) {
-            unlink (gconfig.pidfile);
-            if ((i = open (gconfig.pidfile, O_WRONLY | O_CREAT, 0640)) >= 0)
-            {
-                snprintf (buf, sizeof(buf), "%d\n", (int)getpid());
-                write (i, buf, strlen(buf));
-                close (i);
-                pidfilewritten = 1;
-            }
-        }
-        else
-        {
-            log(LOG_LOG, "%s: There's already a l2tpd server running.\n",
-                    __FUNCTION__);
-            close(server_socket);
-            exit(1);
-        }
-    }
-
-    pid = setsid();
-
-    if(! pidfilewritten) {
-        unlink(gconfig.pidfile);
-        if ((i = open (gconfig.pidfile, O_WRONLY | O_CREAT, 0640)) >= 0) {
-			snprintf (buf, sizeof(buf), "%d\n", (int)getpid());
-            write (i, buf, strlen(buf));
-            close (i);
-            pidfilewritten = 1;
-        }
-    }
-}
-
-
-
-void init (int argc,char *argv[])
-{
-    struct lac *lac;
-    init_args (argc,argv);
-    rand_source = 0;
-    init_addr ();
-    if (init_config ())
-    {
-        log (LOG_CRIT, "%s: Unable to load config file\n", __FUNCTION__);
-        exit (1);
-    }
-    if (uname (&uts))
-    {
-        log (LOG_CRIT, "%s : Unable to determine host system\n",
-             __FUNCTION__);
-        exit (1);
-    }
-    init_tunnel_list (&tunnels);
-    if (init_network ())
-        exit (1);
-    if (gconfig.daemon)
-	daemonize ();
-    signal (SIGTERM, &death_handler);
-    signal (SIGINT, &death_handler);
-    signal (SIGCHLD, &child_handler);
-    signal (SIGUSR1, &status_handler);
-    signal (SIGHUP, &null_handler);
-    init_scheduler ();
-    mkfifo (CONTROL_PIPE, 0600);
-    control_fd = open (CONTROL_PIPE, O_RDONLY | O_NONBLOCK, 0600);
-    if (control_fd < 0)
-    {
-        log (LOG_CRIT, "%s: Unable to open " CONTROL_PIPE " for reading.",
-             __FUNCTION__);
-        exit (1);
-    }
-    log (LOG_LOG, "l2tpd version " SERVER_VERSION " started on %s PID:%d\n",
-         hostname, getpid ());
-    log (LOG_LOG,
-         "Written by Mark Spencer, Copyright (C) 1998, Adtran, Inc.\n");
-    log (LOG_LOG, "Forked by Scott Balmos and David Stipp, (C) 2001\n");
-    log (LOG_LOG, "Inhereted by Jeff McAdams, (C) 2002\n");
-
-    log (LOG_LOG, "%s version %s on a %s, port %d\n", uts.sysname,
-         uts.release, uts.machine, gconfig.port);
-    lac = laclist;
-
-
-    strcpy(lns_server_name, lac->server_name); // Cheni & SJ_Yen
-
-
-    while (lac)
-    {
-        if (lac->autodial)
-        {
+	if ((pid = vfork()) < 0)
+	{
+		log(LOG_LOG, "%s: Unable to fork ()\n", __FUNCTION__);
+		close(server_socket);
+		exit(1);
+	} else if (pid)
+		exit(0);
+
+	/* close(0); *//* This is a hack to "fix" problems with the
+	   daemonization code...more work will be forthcoming 
+	   to do a proper fix for this */
+
+	close(1);
+	close(2);
+#endif
+
+	/* Read previous pid file. */
+	if ((i = open(gconfig.pidfile, O_RDONLY)) > 0)
+	{
+		l = read(i, buf, sizeof(buf) - 1);
+		if (i < 0)
+		{
+			log(LOG_LOG, "%s: Unable to read pid file [%s]\n", __FUNCTION__, gconfig.pidfile);
+		}
+		buf[i] = '\0';
+		pid = atoi(buf);
+
+		/* If the previous server process is not still running,
+		   write a new pid file immediately. */
+		dbg ("%s() kill(pid,0)\n", __FUNCTION__); //eric++
+		if (pid && (pid == getpid() || kill(pid, 0) < 0))
+		{
+			unlink(gconfig.pidfile);
+			if ((i = open(gconfig.pidfile, O_WRONLY | O_CREAT, 0640)) >= 0)
+			{
+				snprintf(buf, sizeof(buf), "%d\n", (int) getpid());
+				write(i, buf, strlen(buf));
+				close(i);
+				pidfilewritten = 1;
+			}
+		} else
+		{
+			log(LOG_LOG, "%s: There's already a l2tpd server running.\n", __FUNCTION__);
+			close(server_socket);
+			exit(1);
+		}
+	}
+
+	pid = setsid();
+
+	if (!pidfilewritten)
+	{
+		unlink(gconfig.pidfile);
+		if ((i = open(gconfig.pidfile, O_WRONLY | O_CREAT, 0640)) >= 0)
+		{
+			snprintf(buf, sizeof(buf), "%d\n", (int) getpid());
+			write(i, buf, strlen(buf));
+			close(i);
+			pidfilewritten = 1;
+		}
+	}
+	dbg ("<< %s()\n", __FUNCTION__); //eric++
+}
+
+
+
+void init(int argc, char *argv[])
+{
+	struct lac *lac;
+	init_args(argc, argv);
+	rand_source = 0;
+	init_addr();
+	if (init_config())
+	{
+		log(LOG_CRIT, "%s: Unable to load config file\n", __FUNCTION__);
+		exit(1);
+	}
+	if (uname(&uts))
+	{
+		log(LOG_CRIT, "%s : Unable to determine host system\n", __FUNCTION__);
+		exit(1);
+	}
+	init_tunnel_list(&tunnels);
+	if (init_network())
+		exit(1);
+	if (gconfig.daemon)
+		daemonize();
+	dbg ("%s() send SIGTERM to death_handler()\n", __FUNCTION__); //eric++
+	signal(SIGTERM, &death_handler);
+	signal(SIGINT, &death_handler);
+	signal(SIGCHLD, &child_handler);
+	signal(SIGUSR1, &status_handler);
+	signal(SIGHUP, &null_handler);
+	init_scheduler();
+	mkfifo(CONTROL_PIPE, 0600);
+	control_fd = open(CONTROL_PIPE, O_RDONLY | O_NONBLOCK, 0600);
+	if (control_fd < 0)
+	{
+		log(LOG_CRIT, "%s: Unable to open " CONTROL_PIPE " for reading.", __FUNCTION__);
+		exit(1);
+	}
+	log(LOG_LOG, "l2tpd version " SERVER_VERSION " started on %s PID:%d\n", hostname, getpid());
+	log(LOG_LOG, "Written by Mark Spencer, Copyright (C) 1998, Adtran, Inc.\n");
+	log(LOG_LOG, "Forked by Scott Balmos and David Stipp, (C) 2001\n");
+	log(LOG_LOG, "Inhereted by Jeff McAdams, (C) 2002\n");
+
+	log(LOG_LOG, "%s version %s on a %s, port %d\n", uts.sysname, uts.release, uts.machine, gconfig.port);
+	lac = laclist;
+
+
+	strcpy(lns_server_name, lac->server_name);	// Cheni & SJ_Yen
+
+
+	while (lac)
+	{
+		if (lac->autodial)
+		{
 #ifdef DEBUG_MAGIC
-            log (LOG_DEBUG, "%s: Autodialing '%s'\n", __FUNCTION__,
-                 lac->entname[0] ? lac->entname : "(unnamed)");
+			log(LOG_DEBUG, "%s: Autodialing '%s'\n", __FUNCTION__, lac->entname[0] ? lac->entname : "(unnamed)");
 #endif
-            lac->active = -1;
-            switch_io = 1;      /* If we're a LAC, autodials will be ICRQ's */
-            magic_lac_dial (lac);
-        }
-        lac = lac->next;
-    }
+			lac->active = -1;
+			switch_io = 1;		/* If we're a LAC, autodials will be ICRQ's */
+			magic_lac_dial(lac);
+		}
+		lac = lac->next;
+	}
 
 }
 
 
-int main (int argc, char *argv[])
+int main(int argc, char *argv[])
 {
 	open("/dev/null", O_RDONLY);
 	open("/dev/null", O_RDONLY);
 	open("/dev/null", O_RDONLY);
-    init(argc,argv);
-    dial_no_tmp = calloc (128, sizeof (char));
+	init(argc, argv);
+	dial_no_tmp = calloc(128, sizeof(char));
 
-    network_thread ();
-    return 0;
-}
+	dbg("network_thread()\n");	//eric++
+	network_thread();
+	dbg("network_thread() OK\n");	//eric++
 
+	return 0;
+}
二元碼檔 l2tpd.orig/l2tpd.gdb 與 l2tpd.20051227/l2tpd.gdb 不同
diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/l2tp.h l2tpd.20051227/l2tp.h
--- l2tpd.orig/l2tp.h	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/l2tp.h	2005-12-27 16:52:30.000000000 +0800
@@ -68,6 +68,9 @@
 
 #define CVER(ver) (ver & 0x0007)        /* Version of encapsulation */
 
+//eric++
+#define dbg(fmt, args...) log_asus (LOG_CRIT, fmt, ##args)
+
 
 struct payload_hdr
 {
diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/Makefile l2tpd.20051227/Makefile
--- l2tpd.orig/Makefile	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/Makefile	2005-12-27 16:52:30.000000000 +0800
@@ -69,6 +69,7 @@
 LDFLAGS += -Wl,-elf2flt=""#-L$(TOP)/nvram -L$(TOP)/shared -L$(TOP)/netconf -lnvram -lshared -lnetconf
 #LDLIBS += l2tp_control.c
 
+.phony: all clean install
 
 all: $(EXEC)
 
@@ -81,3 +82,6 @@
 romfs:
 	$(ROMFSINST) /bin/$(EXEC)
 
+install:
+	cp -f $(EXEC) /Marvell/Src/uClinux-dist/filesystem/target/bin
+
diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/misc.c l2tpd.20051227/misc.c
--- l2tpd.orig/misc.c	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/misc.c	2005-12-27 16:52:30.000000000 +0800
@@ -32,7 +32,8 @@
 
 void log (int level, const char *fmt, ...)
 {
-/*    char buf[256];
+//eric**, log() had been comment by someone else
+    char buf[256];
     va_list args;
     va_start (args, fmt);
     vsnprintf (buf, sizeof (buf), fmt, args);
@@ -42,7 +43,7 @@
     fflush (stderr);
     openlog (BINARY, LOG_PID, LOG_DAEMON);
     syslog (level, "%s", buf);
-    va_end (args);*/
+    va_end (args);
 }
 
 void log_asus (int level, const char *fmt, ...)
diff -urN -x '*.o' -x l2tpd -x '*.swp' l2tpd.orig/network.c l2tpd.20051227/network.c
--- l2tpd.orig/network.c	2005-12-27 16:31:21.000000000 +0800
+++ l2tpd.20051227/network.c	2005-12-27 16:52:30.000000000 +0800
@@ -25,136 +25,129 @@
 #include "l2tp.h"
 
 char hostname[256];
-unsigned int listen_addy = INADDR_ANY;  /* Address to listen on */
-struct sockaddr_in server, from;        /* Server and transmitter structs */
-int server_socket;              /* Server socket */
+unsigned int listen_addy = INADDR_ANY;	/* Address to listen on */
+struct sockaddr_in server, from;	/* Server and transmitter structs */
+int server_socket;				/* Server socket */
 #ifdef USE_KERNEL
-int kernel_support;             /* Kernel Support there or not? */
+int kernel_support;				/* Kernel Support there or not? */
 #endif
 
 /*
  * Debugging info
  */
 int debug_tunnel = 1;
-int debug_network = 0;          /* Debug networking? */
-int packet_dump = 0;            /* Dump packets? */
-int debug_avp = 1;              /* Debug AVP negotiations? */
-int debug_state = 0;            /* Debug state machine? */
+int debug_network = 0;			/* Debug networking? */
+int packet_dump = 0;			/* Dump packets? */
+int debug_avp = 1;				/* Debug AVP negotiations? */
+int debug_state = 0;			/* Debug state machine? */
 
-int init_network (void)
+int init_network(void)
 {
-    long arg;
-    int length = sizeof (server);
-    int debug_ret = 0;
-
-    gethostname (hostname, sizeof (hostname));
-    server.sin_family = AF_INET;
-    server.sin_addr.s_addr = htonl (listen_addy);
-    server.sin_port = htons (gconfig.port);
-    if ((server_socket = socket (PF_INET, SOCK_DGRAM, 0)) < 0)
-    {
-        log (LOG_CRIT, "%s: Unable to allocate socket. Terminating.\n",
-             __FUNCTION__);
-        return -EINVAL;
-    };
-    /* L2TP/IPSec: Set up SA for listening port here?  NTB 20011015
-     */
-    //SJ_Yen
-    debug_ret = bind (server_socket, (struct sockaddr *) &server, sizeof (server));
+	long arg;
+	int length = sizeof(server);
+	int debug_ret = 0;
+
+	gethostname(hostname, sizeof(hostname));
+	server.sin_family = AF_INET;
+	server.sin_addr.s_addr = htonl(listen_addy);
+	server.sin_port = htons(gconfig.port);
+	if ((server_socket = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
+	{
+		log(LOG_CRIT, "%s: Unable to allocate socket. Terminating.\n", __FUNCTION__);
+		return -EINVAL;
+	};
+	/* L2TP/IPSec: Set up SA for listening port here?  NTB 20011015
+	 */
+	//SJ_Yen
+	debug_ret = bind(server_socket, (struct sockaddr *) &server, sizeof(server));
 
 //    if (bind (server_socket, (struct sockaddr *) &server, sizeof (server)))
-    if (debug_ret != 0)
-    {
-        close (server_socket);
-        log (LOG_CRIT, "%s: Unable to bind socket. Terminating.\n",
-             __FUNCTION__);
-        return -EINVAL;
-    };
-    if (getsockname (server_socket, (struct sockaddr *) &server, &length))
-    {
-        log (LOG_CRIT, "%s: Unable to read socket name.Terminating.\n",
-             __FUNCTION__);
-        return -EINVAL;
-    }
+	if (debug_ret != 0)
+	{
+		close(server_socket);
+		log(LOG_CRIT, "%s: Unable to bind socket. Terminating.\n", __FUNCTION__);
+		return -EINVAL;
+	};
+	if (getsockname(server_socket, (struct sockaddr *) &server, &length))
+	{
+		log(LOG_CRIT, "%s: Unable to read socket name.Terminating.\n", __FUNCTION__);
+		return -EINVAL;
+	}
 #ifdef USE_KERNEL
-    if (gconfig.forceuserspace)
-    {
-        log (LOG_LOG, "Not looking for kernel support.\n");
-        kernel_support = 0;
-    }
-    else
-    {
-        if (ioctl (server_socket, SIOCSETL2TP, NULL) < 0)
-        {
-            log (LOG_LOG, "L2TP kernel support not detected.\n");
-            kernel_support = 0;
-        }
-        else
-        {
-            log (LOG_LOG, "Using l2tp kernel support.\n");
-            kernel_support = -1;
-        }
-    }
+	if (gconfig.forceuserspace)
+	{
+		log(LOG_LOG, "Not looking for kernel support.\n");
+		kernel_support = 0;
+	} else
+	{
+		if (ioctl(server_socket, SIOCSETL2TP, NULL) < 0)
+		{
+			log(LOG_LOG, "L2TP kernel support not detected.\n");
+			kernel_support = 0;
+		} else
+		{
+			log(LOG_LOG, "Using l2tp kernel support.\n");
+			kernel_support = -1;
+		}
+	}
 #else
-    log (LOG_LOG, "This binary does not support kernel L2TP.\n");
+	log(LOG_LOG, "This binary does not support kernel L2TP.\n");
 #endif
-    arg = fcntl (server_socket, F_GETFL);
-    arg |= O_NONBLOCK;
-    fcntl (server_socket, F_SETFL, arg);
-    gconfig.port = ntohs (server.sin_port);
-    return 0;
+	arg = fcntl(server_socket, F_GETFL);
+	arg |= O_NONBLOCK;
+	fcntl(server_socket, F_SETFL, arg);
+	gconfig.port = ntohs(server.sin_port);
+	return 0;
 }
 
-inline void extract (void *buf, int *tunnel, int *call)
+inline void extract(void *buf, int *tunnel, int *call)
 {
-    /*
-     * Extract the tunnel and call #'s, and fix the order of the 
-     * version
-     */
-
-    struct payload_hdr *p = (struct payload_hdr *) buf;
-    if (PLBIT (p->ver))
-    {
-        *tunnel = p->tid;
-        *call = p->cid;
-    }
-    else
-    {
-        *tunnel = p->length;
-        *call = p->tid;
-    }
+	/*
+	 * Extract the tunnel and call #'s, and fix the order of the 
+	 * version
+	 */
+
+	struct payload_hdr *p = (struct payload_hdr *) buf;
+	if (PLBIT(p->ver))
+	{
+		*tunnel = p->tid;
+		*call = p->cid;
+	} else
+	{
+		*tunnel = p->length;
+		*call = p->tid;
+	}
 }
 
-inline void fix_hdr (void *buf)
+inline void fix_hdr(void *buf)
 {
-    /*
-     * Fix the byte order of the header
-     */
-
-    struct payload_hdr *p = (struct payload_hdr *) buf;
-    _u16 ver = ntohs (p->ver);
-    if (CTBIT (p->ver))
-    {
-        /*
-         * Control headers are always
-         * exactly 12 bytes big.
-         */
-        swaps (buf, 12);
-    }
-    else
-    {
-        int len = 6;
-        if (PSBIT (ver))
-            len += 4;
-        if (PLBIT (ver))
-            len += 2;
-        if (PFBIT (ver))
-            len += 4;
-        swaps (buf, len);
-    }
+	/*
+	 * Fix the byte order of the header
+	 */
+
+	struct payload_hdr *p = (struct payload_hdr *) buf;
+	_u16 ver = ntohs(p->ver);
+	if (CTBIT(p->ver))
+	{
+		/*
+		 * Control headers are always
+		 * exactly 12 bytes big.
+		 */
+		swaps(buf, 12);
+	} else
+	{
+		int len = 6;
+		if (PSBIT(ver))
+			len += 4;
+		if (PLBIT(ver))
+			len += 2;
+		if (PFBIT(ver))
+			len += 4;
+		swaps(buf, len);
+	}
 }
 
-void dethrottle (void *call)
+void dethrottle(void *call)
 {
 /*	struct call *c = (struct call *)call; */
 /*	if (c->throttle) {
@@ -167,414 +160,387 @@
 	} */
 }
 
-void control_xmit (void *b)
+void control_xmit(void *b)
 {
-    struct buffer *buf = (struct buffer *) b;
-    struct tunnel *t;
-    struct timeval tv;
-    int ns;
-    if (!buf)
-    {
-        log (LOG_WARN, "%s: called on NULL buffer!\n", __FUNCTION__);
-        return;
-    }
-
-    buf->retries++;
-    t = buf->tunnel;
-    ns = ntohs (((struct control_hdr *) (buf->start))->Ns);
-    if (t)
-    {
-        if (ns < t->cLr)
-        {
+	struct buffer *buf = (struct buffer *) b;
+	struct tunnel *t;
+	struct timeval tv;
+	int ns;
+	if (!buf)
+	{
+		log(LOG_WARN, "%s: called on NULL buffer!\n", __FUNCTION__);
+		return;
+	}
+
+	buf->retries++;
+	t = buf->tunnel;
+	ns = ntohs(((struct control_hdr *) (buf->start))->Ns);
+	if (t)
+	{
+		if (ns < t->cLr)
+		{
 #ifdef DEBUG_CONTROL_XMIT
-            log (LOG_DEBUG, "%s: Tossing packet %d\n", __FUNCTION__, ns);
+			log(LOG_DEBUG, "%s: Tossing packet %d\n", __FUNCTION__, ns);
 #endif
-            /* Okay, it's been received.  Let's toss it now */
-            toss (buf);
-            return;
-        }
-    }
-    if (buf->retries > DEFAULT_MAX_RETRIES)
-    {
-        /*
-           * Too many retries.  Either kill the tunnel, or
-           * if there is no tunnel, just stop retransmitting.
-         */
-        if (t)
-        {
-            if (t->self->needclose)
-            {
-                log (LOG_DEBUG,
-                     "%s: Unable to deliver closing message for tunnel %d. Destroying anyway.\n",
-                     __FUNCTION__, t->ourtid);
-                t->self->needclose = 0;
-                t->self->closing = -1;
-            }
-            else
-            {
-                log (LOG_DEBUG,
-                     "%s: Maximum retries exceeded for tunnel %d.  Closing.\n",
-                     __FUNCTION__, t->ourtid);
-                strcpy (t->self->errormsg, "Timeout");
-                t->self->needclose = -1;
-            }
-        }
-    }
-    else
-    {
-        /*
-           * FIXME:  How about adaptive timeouts?
-         */
-        tv.tv_sec = 1;
-        tv.tv_usec = 0;
-        schedule (tv, control_xmit, buf);
+			/* Okay, it's been received.  Let's toss it now */
+			toss(buf);
+			return;
+		}
+	}
+	if (buf->retries > DEFAULT_MAX_RETRIES)
+	{
+		/*
+		 * Too many retries.  Either kill the tunnel, or
+		 * if there is no tunnel, just stop retransmitting.
+		 */
+		if (t)
+		{
+			if (t->self->needclose)
+			{
+				log(LOG_DEBUG, "%s: Unable to deliver closing message for tunnel %d. Destroying anyway.\n", __FUNCTION__, t->ourtid);
+				t->self->needclose = 0;
+				t->self->closing = -1;
+			} else
+			{
+				log(LOG_DEBUG, "%s: Maximum retries exceeded for tunnel %d.  Closing.\n", __FUNCTION__, t->ourtid);
+				strcpy(t->self->errormsg, "Timeout");
+				t->self->needclose = -1;
+			}
+		}
+	} else
+	{
+		/*
+		 * FIXME:  How about adaptive timeouts?
+		 */
+		tv.tv_sec = 1;
+		tv.tv_usec = 0;
+		schedule(tv, control_xmit, buf);
 #ifdef DEBUG_CONTROL_XMIT
-        log (LOG_DEBUG, "%s: Scheduling and transmitting packet %d\n",
-             __FUNCTION__, ns);
+		log(LOG_DEBUG, "%s: Scheduling and transmitting packet %d\n", __FUNCTION__, ns);
 #endif
-        udp_xmit (buf);
-    }
+		udp_xmit(buf);
+	}
 }
 
-void udp_xmit (struct buffer *buf)
+void udp_xmit(struct buffer *buf)
 {
 	int xxx = 0;
-    /*
-     * Just send it all out.
-     */
-//	printf("packet dump for UDP_XMIT\n");
-//	do_packet_dump(buf);
- 
+	/*
+	 * Just send it all out.
+	 */
+//  printf("packet dump for UDP_XMIT\n");
+//  do_packet_dump(buf);
+
 
 #if 0
-    struct sockaddr_in to;
-    to.sin_family = AF_INET;
-    to.sin_port = buf->port;
-    /* if (buf->retry>-1) buf->retry++; */
-    bcopy (&buf->addr, &to.sin_addr, sizeof (buf->addr));
+	struct sockaddr_in to;
+	to.sin_family = AF_INET;
+	to.sin_port = buf->port;
+	/* if (buf->retry>-1) buf->retry++; */
+	bcopy(&buf->addr, &to.sin_addr, sizeof(buf->addr));
 #endif
 
-//	printf("peer.sin_family=%x, peer.sin_addr.s_addr=%x, peer.sin_port=%x \n", buf->peer.sin_family, buf->peer.sin_addr.s_addr, buf->peer.sin_port);
-//	printf("socket.start.size=%x,socket.len.size=%x,socket.peer.size=%x\n",sizeof(buf->start),sizeof(buf->len),sizeof(buf->peer));
+//  printf("peer.sin_family=%x, peer.sin_addr.s_addr=%x, peer.sin_port=%x \n", buf->peer.sin_family, buf->peer.sin_addr.s_addr, buf->peer.sin_port);
+//  printf("socket.start.size=%x,socket.len.size=%x,socket.peer.size=%x\n",sizeof(buf->start),sizeof(buf->len),sizeof(buf->peer));
 
-//	do_packet_dump(&buf->start);
-//	do_packet_dump(&buf->peer);
-	xxx = sendto (server_socket, buf->start, buf->len, 0,
-		(struct sockaddr *) &buf->peer, sizeof (buf->peer));
-#if 0//SJ_Yen
-	xxx = sendto (server_socket, buf->start, buf->len, 0,
-		(struct sockaddr *) &buf->peer, sizeof (buf->peer));
+//  do_packet_dump(&buf->start);
+//  do_packet_dump(&buf->peer);
+	xxx = sendto(server_socket, buf->start, buf->len, 0, (struct sockaddr *) &buf->peer, sizeof(buf->peer));
+#if 0							//SJ_Yen
+	xxx = sendto(server_socket, buf->start, buf->len, 0, (struct sockaddr *) &buf->peer, sizeof(buf->peer));
 
-	xxx = sendto (server_socket, buf->start, buf->len, 0,
-		(struct sockaddr *) &buf->peer, sizeof (buf->peer));
+	xxx = sendto(server_socket, buf->start, buf->len, 0, (struct sockaddr *) &buf->peer, sizeof(buf->peer));
 
-	xxx = sendto (server_socket, buf->start, buf->len, 0,
-                (struct sockaddr *) &buf->peer, sizeof (buf->peer));
+	xxx = sendto(server_socket, buf->start, buf->len, 0, (struct sockaddr *) &buf->peer, sizeof(buf->peer));
 #endif
-//	log (LOG_DEBUG, "server_socket=%x\n", server_socket);
-//	log (LOG_DEBUG, "sendto=%x, errno=%x\n", xxx, errno);
-//	log (LOG_DEBUG, "sockaddr=%x\n", (struct sockaddr *) &buf->peer);
-//	log_asus (LOG_DEBUG, "peer.sin_family=%x, peer.sin_addr.s_addr=%x, peer.sin_port=%x \n", buf->peer.sin_family, buf->peer.sin_addr.s_addr, buf->peer.sin_port);
+//  log (LOG_DEBUG, "server_socket=%x\n", server_socket);
+//  log (LOG_DEBUG, "sendto=%x, errno=%x\n", xxx, errno);
+//  log (LOG_DEBUG, "sockaddr=%x\n", (struct sockaddr *) &buf->peer);
+//  log_asus (LOG_DEBUG, "peer.sin_family=%x, peer.sin_addr.s_addr=%x, peer.sin_port=%x \n", buf->peer.sin_family, buf->peer.sin_addr.s_addr, buf->peer.sin_port);
 
 }
 
-void network_thread ()
+void network_thread()
 {
-    /*
-     * We loop forever waiting on either data from the ppp drivers or from
-     * our network socket.  Control handling is no longer done here.
-     */
-    int fromlen;                /* Length of the address */
-    int tunnel, call;           /* Tunnel and call */
-    int recvsize;               /* Length of data received */
-    struct buffer *buf;         /* Payload buffer */
-    struct call *c, *sc;        /* Call to send this off to */
-    struct tunnel *st;          /* Tunnel */
-    fd_set readfds;             /* Descriptors to watch for reading */
-    int max;                    /* Highest fd */
-    struct timeval tv;          /* Timeout for select */
-    int debug_num = 0;
+	/*
+	 * We loop forever waiting on either data from the ppp drivers or from
+	 * our network socket.  Control handling is no longer done here.
+	 */
+	int fromlen;				/* Length of the address */
+	int tunnel, call;			/* Tunnel and call */
+	int recvsize;				/* Length of data received */
+	struct buffer *buf;			/* Payload buffer */
+	struct call *c, *sc;		/* Call to send this off to */
+	struct tunnel *st;			/* Tunnel */
+	fd_set readfds;				/* Descriptors to watch for reading */
+	int max;					/* Highest fd */
+	struct timeval tv;			/* Timeout for select */
+	int debug_num = 0;
 
 #if 0
-	char *sendtomsg1="11111TestSendtoFunc";
-	char *sendtomsg2="22222TestSendtoFunc";
-	char *sendtomsg3="33333TestSendtoFunc";
-	int lenofmsg1=sizeof(sendtomsg1)+sizeof(buf->peer);
-	int lenofmsg2=sizeof(sendtomsg2)+sizeof(buf->peer);
-	int lenofmsg3=sizeof(sendtomsg3)+sizeof(buf->peer);
+	char *sendtomsg1 = "11111TestSendtoFunc";
+	char *sendtomsg2 = "22222TestSendtoFunc";
+	char *sendtomsg3 = "33333TestSendtoFunc";
+	int lenofmsg1 = sizeof(sendtomsg1) + sizeof(buf->peer);
+	int lenofmsg2 = sizeof(sendtomsg2) + sizeof(buf->peer);
+	int lenofmsg3 = sizeof(sendtomsg3) + sizeof(buf->peer);
 #endif
-    /* This one buffer can be recycled for everything except control packets */
-    buf = new_buf (MAX_RECV_SIZE);
-    for (;;)
-    {
-        /*
-           * First, let's send out any outgoing packets that are waiting on us.
-           * xmit_udp should only
-           * contain control packets in the unthreaded version!
-         */
-        max = 0;
+	/* This one buffer can be recycled for everything except control packets */
+	buf = new_buf(MAX_RECV_SIZE);
+	for (;;)
+	{
+		/*
+		 * First, let's send out any outgoing packets that are waiting on us.
+		 * xmit_udp should only
+		 * contain control packets in the unthreaded version!
+		 */
+		max = 0;
 
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before FD_ZERO(&XXXX)@network.c\n");
-        }
+		}
 
-        FD_ZERO (&readfds);
+		FD_ZERO(&readfds);
 
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
-  //              log (LOG_DEBUG, "Debug msg before st=tunnels.head@network.c\n");
-        }
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
+			//              log (LOG_DEBUG, "Debug msg before st=tunnels.head@network.c\n");
+		}
 
-        st = tunnels.head;
+		st = tunnels.head;
 
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before while(st)@network.c\n");
-	}
+		}
 
-        while (st)
-        {
-            if (st->self->needclose ^ st->self->closing)
-            {
-                if (debug_tunnel)
-                    log (LOG_DEBUG, "%S: closing down tunnel %d\n",
-                         __FUNCTION__, st->ourtid);
-                call_close (st->self);
-                /* Reset the while loop
-                   and check for NULL */
-                st = tunnels.head;
-                if (!st){
-		    if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        		{
-//                	log (LOG_DEBUG, "Debug msg before break at while(st)@network.c\n");
-        		}
-                    break;
-		}
-                continue;
-            }
-	    if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        	{
+		while (st)
+		{
+			if (st->self->needclose ^ st->self->closing)
+			{
+				if (debug_tunnel)
+					log(LOG_DEBUG, "%S: closing down tunnel %d\n", __FUNCTION__, st->ourtid);
+				call_close(st->self);
+				/* Reset the while loop
+				   and check for NULL */
+				st = tunnels.head;
+				if (!st)
+				{
+					if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+					{
+//                  log (LOG_DEBUG, "Debug msg before break at while(st)@network.c\n");
+					}
+					break;
+				}
+				continue;
+			}
+			if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+			{
 //                log (LOG_DEBUG, "Debug msg before sc = st->call_head@network.c\n");
-        	}
-            sc = st->call_head;
+			}
+			sc = st->call_head;
 
-	    if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        	{
+			if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+			{
 //                log (LOG_DEBUG, "Debug msg before while(sc)@network.c\n");
-        	}
+			}
 
-            while (sc)
-            {
-                if (sc->needclose ^ sc->closing)
-                {
-                    call_close (sc);
-                    sc = st->call_head;
-                    if (!sc){
-			if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        		{
-//                	log (LOG_DEBUG, "Debug msg before break at while(sc)@network.c\n");
-		        }
-                        break;
-		    }
-                    continue;
-                }
-                if (sc->fd > -1)
-                {
-/*					if (!sc->throttle && !sc->needclose && !sc->closing) { */
-                    if (!sc->needclose && !sc->closing)
-                    {
-                        if (sc->fd > max)
-                            max = sc->fd;
-                        FD_SET (sc->fd, &readfds);
-                    }
-                }
-		if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        	{
+			while (sc)
+			{
+				if (sc->needclose ^ sc->closing)
+				{
+					call_close(sc);
+					sc = st->call_head;
+					if (!sc)
+					{
+						if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+						{
+//                  log (LOG_DEBUG, "Debug msg before break at while(sc)@network.c\n");
+						}
+						break;
+					}
+					continue;
+				}
+				if (sc->fd > -1)
+				{
+/*					if (!sc->throttle && !sc->needclose && !sc->closing) */
+					if (!sc->needclose && !sc->closing)
+					{
+						if (sc->fd > max)
+							max = sc->fd;
+						FD_SET(sc->fd, &readfds);
+					}
+				}
+				if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+				{
 //                log (LOG_DEBUG, "Debug msg before sc = sc->next@network.c\n");
-        	}
-                sc = sc->next;
-            }
-	    if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        	{
+				}
+				sc = sc->next;
+			}
+			if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+			{
 //                log (LOG_DEBUG, "Debug msg before st = st->next@network.c\n");
-        	}
-            st = st->next;
-        }
-	
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+			}
+			st = st->next;
+		}
+
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before FD_SET(server_socket...)@network.c\n");
-        }
-        FD_SET (server_socket, &readfds);
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		FD_SET(server_socket, &readfds);
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before max = server_socket@network.c\n");
-        }
-        if (server_socket > max)
-            max = server_socket;
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		if (server_socket > max)
+			max = server_socket;
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before FD_SET(control_fd...)@network.c\n");
-        }
-        FD_SET (control_fd, &readfds);
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		FD_SET(control_fd, &readfds);
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before max = control_fd@network.c\n");
-        }
-        if (control_fd > max)
-            max = control_fd;
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		if (control_fd > max)
+			max = control_fd;
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before tv.tv_sec@network.c\n");
-        }
-        tv.tv_sec = 1;
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		tv.tv_sec = 1;
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before tv.tv_usec@network.c\n");
-        }
-        tv.tv_usec = 0;
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+		tv.tv_usec = 0;
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before schedule_unlock@network.c\n");
-        }
-//	if (strlen(lns_server_name) == 0){
-        schedule_unlock ();
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		}
+//  if (strlen(lns_server_name) == 0){
+		schedule_unlock();
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before select(max + 1 ...)@network.c\n");
-		debug_num = select (max + 1, &readfds, NULL, NULL, NULL);
-//		log (LOG_DEBUG, "Debug msg after select, the ret = %d @network.c\n", debug_num);
-        }
-	else
-        select (max + 1, &readfds, NULL, NULL, NULL);
+			debug_num = select(max + 1, &readfds, NULL, NULL, NULL);
+//      log (LOG_DEBUG, "Debug msg after select, the ret = %d @network.c\n", debug_num);
+		} else
+			select(max + 1, &readfds, NULL, NULL, NULL);
 
-	if (strlen(lns_server_name)!=0)  // Cheni & SJ_Yen
-        {
+		if (strlen(lns_server_name) != 0)	// Cheni & SJ_Yen
+		{
 //                log (LOG_DEBUG, "Debug msg before schedule_unlock2..@network.c\n");
-        }
-        schedule_lock ();
-//	}
+		}
+		schedule_lock();
+//  }
 
-        if ((FD_ISSET (control_fd, &readfds))||(strlen(lns_server_name)!=0))
-        {
+		if ((FD_ISSET(control_fd, &readfds)) || (strlen(lns_server_name) != 0))
+		{
 //            log (LOG_DEBUG, "Debug MSG::: The lns_server_name is '%s' at network.c before do_control!!\n", lns_server_name);
-//	    log (LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' at network.c before do_control!!\n", strlen(lns_server_name));
-            do_control ();
-        }
-        if (FD_ISSET (server_socket, &readfds))
-        {
-            /*
-             * Okay, now we're ready for reading and processing new data.
-             */
-            recycle_buf (buf);
-            /* Reserve space for expanding payload packet headers */
-            buf->start += PAYLOAD_BUF;
-            buf->len -= PAYLOAD_BUF;
-            fromlen = sizeof (from);
-            recvsize =
-                recvfrom (server_socket, buf->start, buf->len, 0,
-                          (struct sockaddr *) &from, &fromlen);
-            if (recvsize < MIN_PAYLOAD_HDR_LEN)
-            {
-                if (recvsize < 0)
-                {
-                    if (errno != EAGAIN)
-                        log (LOG_WARN,
-                             "%s: recvfrom returned error %d (%s)\n",
-                             __FUNCTION__, errno, strerror (errno));
-                }
-                else
-                {
-                    log (LOG_WARN, "%s: received too small a packet\n",
-                         __FUNCTION__);
-                }
-            }
-            else
-            {
-                buf->len = recvsize;
-                if (packet_dump)
-                {
-                    do_packet_dump (buf);
-                }
-                fix_hdr (buf->start);
-                extract (buf->start, &tunnel, &call);
-                if (debug_network)
-                {
-                    log (LOG_DEBUG, "%s: recv packet from %s, size = %d,
-tunnel = %d, call = %d\n", __FUNCTION__, inet_ntoa (from.sin_addr), recvsize, tunnel, call);
-                }
-                if (packet_dump)
-                {
-                    do_packet_dump (buf);
-                }
-                if (!
-                    (c =
-                     get_call (tunnel, call, from.sin_addr.s_addr,
-                               from.sin_port)))
-                {
-                    if ((c =
-                         get_tunnel (tunnel, from.sin_addr.s_addr,
-                                     from.sin_port)))
-                    {
-                        /*
-                         * It is theoretically possible that we could be sent
-                         * a control message (say a StopCCN) on a call that we
-                         * have already closed or some such nonsense.  To prevent
-                         * this from closing the tunnel, if we get a call on a valid
-                         * tunnel, but not with a valid CID, we'll just send a ZLB
-                         * to ack receiving the packet.
-                         */
-                        if (debug_tunnel)
-                            log (LOG_DEBUG,
-                                 "%s: no such call %d on tunnel %d.  Sending special ZLB\n",
-                                 __FUNCTION__);
-                        handle_special (buf, c, call);
-                    }
-                    else
-                        log (LOG_DEBUG,
-                             "%s: unable to find call or tunnel to handle packet.  call = %d, tunnel = %d Dumping.\n",
-                             __FUNCTION__, call, tunnel);
-
-                }
-                else
-                {
-                    buf->peer = from;
-                    /* Handle the packet */
-                    c->container->chal_us.vector = NULL;
-                    if (handle_packet (buf, c->container, c))
-                    {
-                        if (debug_tunnel)
-                            log (LOG_DEBUG, "%s: bad packet\n", __FUNCTION__);
-                    };
-                    if (c->cnu)
-                    {
-                        /* Send Zero Byte Packet */
-                        control_zlb (buf, c->container, c);
-                        c->cnu = 0;
-                    }
-                }
-            }
-        };
-
-        st = tunnels.head;
-        while (st)
-        {
-//		printf("start st\n");
-            sc = st->call_head;
-            while (sc)
-            {
-//		printf("start sc\n");
-                if ((sc->fd >= 0) && FD_ISSET (sc->fd, &readfds))
-                {
-                    /* Got some payload to send */
-			//printf("Got some payload to send\n");
-                    int result;
-		//	printf("Got some payload to send\n");
-                    recycle_payload (buf, sc->container->peer);
+//      log (LOG_DEBUG, "Debug MSG::: The length of lns_server_name is '%d' at network.c before do_control!!\n", strlen(lns_server_name));
+			do_control();
+		}
+		if (FD_ISSET(server_socket, &readfds))
+		{
+			/*
+			 * Okay, now we're ready for reading and processing new data.
+			 */
+			recycle_buf(buf);
+			/* Reserve space for expanding payload packet headers */
+			buf->start += PAYLOAD_BUF;
+			buf->len -= PAYLOAD_BUF;
+			fromlen = sizeof(from);
+			recvsize = recvfrom(server_socket, buf->start, buf->len, 0, (struct sockaddr *) &from, &fromlen);
+			if (recvsize < MIN_PAYLOAD_HDR_LEN)
+			{
+				if (recvsize < 0)
+				{
+					if (errno != EAGAIN)
+						log(LOG_WARN, "%s: recvfrom returned error %d (%s)\n", __FUNCTION__, errno, strerror(errno));
+				} else
+				{
+					log(LOG_WARN, "%s: received too small a packet\n", __FUNCTION__);
+				}
+			} else
+			{
+				buf->len = recvsize;
+				if (packet_dump)
+				{
+					do_packet_dump(buf);
+				}
+				fix_hdr(buf->start);
+				extract(buf->start, &tunnel, &call);
+				dbg("%s() extract tunnel %d call %d\n", __FUNCTION__, tunnel, call); //eric++
+				if (debug_network)
+				{
+					log(LOG_DEBUG, "%s: recv packet from %s, size = %d,
+tunnel = %d, call = %d\n", __FUNCTION__, inet_ntoa(from.sin_addr), recvsize, tunnel, call);
+				}
+				if (packet_dump)
+				{
+					do_packet_dump(buf);
+				}
+				if (!(c = get_call(tunnel, call, from.sin_addr.s_addr, from.sin_port)))
+				{
+					if ((c = get_tunnel(tunnel, from.sin_addr.s_addr, from.sin_port)))
+					{
+						/*
+						 * It is theoretically possible that we could be sent
+						 * a control message (say a StopCCN) on a call that we
+						 * have already closed or some such nonsense.  To prevent
+						 * this from closing the tunnel, if we get a call on a valid
+						 * tunnel, but not with a valid CID, we'll just send a ZLB
+						 * to ack receiving the packet.
+						 */
+						if (debug_tunnel)
+							log(LOG_DEBUG, "%s: no such call %d on tunnel %d.  Sending special ZLB\n", __FUNCTION__);
+						handle_special(buf, c, call);
+					} else
+						log(LOG_DEBUG, "%s: unable to find call or tunnel to handle packet.  call = %d, tunnel = %d Dumping.\n", __FUNCTION__, call, tunnel);
+
+				} else
+				{
+					buf->peer = from;
+					/* Handle the packet */
+					c->container->chal_us.vector = NULL;
+					if (handle_packet(buf, c->container, c))
+					{
+						if (debug_tunnel)
+							log(LOG_DEBUG, "%s: bad packet\n", __FUNCTION__);
+					};
+					if (c->cnu)
+					{
+						/* Send Zero Byte Packet */
+						control_zlb(buf, c->container, c);
+						c->cnu = 0;
+					}
+				}
+			}
+			dbg ("if (recvsize >= MIN_PAYLOAD_HDR_LEN) end\n"); //eric++
+		};
+
+		st = tunnels.head;
+		dbg ("while (st) %p\n", st); //eric++
+		while (st)
+		{
+//      printf("start st\n");
+			sc = st->call_head;
+			while (sc)
+			{
+//      printf("start sc\n");
+				if ((sc->fd >= 0) && FD_ISSET(sc->fd, &readfds))
+				{
+					/* Got some payload to send */
+					//printf("Got some payload to send\n");
+					int result;
+					//  printf("Got some payload to send\n");
+					recycle_payload(buf, sc->container->peer);
 #ifdef DEBUG_FLOW
-                    log (LOG_DEBUG, "%s: rws = %d, pSs = %d, pLr = %d\n",
-                         __FUNCTION__, sc->rws, sc->pSs, sc->pLr);
+					log(LOG_DEBUG, "%s: rws = %d, pSs = %d, pLr = %d\n", __FUNCTION__, sc->rws, sc->pSs, sc->pLr);
 #endif
 /*					if ((sc->rws>0) && (sc->pSs > sc->pLr + sc->rws) && !sc->rbit) {
 #ifdef DEBUG_FLOW
@@ -590,56 +556,54 @@
 						tv.tv_usec = 0;
 						sc->dethrottle = schedule(tv, dethrottle, sc); 					
 					} else */
-/*					while ((result=read_packet(buf,sc->fd,sc->frame & SYNC_FRAMING))>0) { */
-	//	sendto (server_socket, sendtomsg1, lenofmsg1, 0,
-	//		(struct sockaddr *) &buf->peer, sizeof (buf->peer));
-
-                    while ((result =
-                            read_packet (buf, sc->fd, SYNC_FRAMING)) > 0)
-                    {
-//			do_packet_dump(buf);
-		//	printf("read packet (buf, sc->fd)...\n");
-                        add_payload_hdr (sc->container, sc, buf);
-                        if (packet_dump)
-                        {
-                            do_packet_dump (buf);
-                        }
-
-
-                        sc->prx = sc->data_rec_seq_num;
-                        if (sc->zlb_xmit)
-                        {
-		//		printf("sc->zlb_xmit\n");
-                            deschedule (sc->zlb_xmit);
-                            sc->zlb_xmit = NULL;
-                        }
-		//	printf("start sc->tx_bytes += buf->len\n");
-                        sc->tx_bytes += buf->len;
-		//	printf("start sc->tx_pkts++\n");
-                        sc->tx_pkts++;
-		//	printf("start udp_xmit\n");
-		//	sendto (server_socket, sendtomsg2, lenofmsg2, 0,
-                //	(struct sockaddr *) &buf->peer, sizeof (buf->peer));
-                        udp_xmit (buf);
-		//	sendto (server_socket, sendtomsg3, lenofmsg3, 0,
-                //        (struct sockaddr *) &buf->peer, sizeof (buf->peer));
-		//	printf("start recycle_payload\n");
-                        recycle_payload (buf, sc->container->peer);
-                    }
-                    if (result != 0)
-                    {
-                        log (LOG_WARN,
-                             "%s: tossing read packet, error = %s (%d).  Closing call.\n",
-                             __FUNCTION__, strerror (-result), -result);
-                        strcpy (sc->errormsg, strerror (-result));
-                        sc->needclose = -1;
-                    }
-                }
-//		printf("end before sc\n");
-                sc = sc->next;
-            }
-            st = st->next;
-        }
-    }
+/*					while ((result=read_packet(buf,sc->fd,sc->frame & SYNC_FRAMING))>0) */
+					//  sendto (server_socket, sendtomsg1, lenofmsg1, 0,
+					//      (struct sockaddr *) &buf->peer, sizeof (buf->peer));
+
+					while ((result = read_packet(buf, sc->fd, SYNC_FRAMING)) > 0)
+					{
+//          do_packet_dump(buf);
+						//  printf("read packet (buf, sc->fd)...\n");
+						add_payload_hdr(sc->container, sc, buf);
+						if (packet_dump)
+						{
+							do_packet_dump(buf);
+						}
+
+
+						sc->prx = sc->data_rec_seq_num;
+						if (sc->zlb_xmit)
+						{
+							//      printf("sc->zlb_xmit\n");
+							deschedule(sc->zlb_xmit);
+							sc->zlb_xmit = NULL;
+						}
+						//  printf("start sc->tx_bytes += buf->len\n");
+						sc->tx_bytes += buf->len;
+						//  printf("start sc->tx_pkts++\n");
+						sc->tx_pkts++;
+						//  printf("start udp_xmit\n");
+						//  sendto (server_socket, sendtomsg2, lenofmsg2, 0,
+						//  (struct sockaddr *) &buf->peer, sizeof (buf->peer));
+						udp_xmit(buf);
+						//  sendto (server_socket, sendtomsg3, lenofmsg3, 0,
+						//        (struct sockaddr *) &buf->peer, sizeof (buf->peer));
+						//  printf("start recycle_payload\n");
+						recycle_payload(buf, sc->container->peer);
+					}
+					if (result != 0)
+					{
+						log(LOG_WARN, "%s: tossing read packet, error = %s (%d).  Closing call.\n", __FUNCTION__, strerror(-result), -result);
+						strcpy(sc->errormsg, strerror(-result));
+						sc->needclose = -1;
+					}
+				}
+//      printf("end before sc\n");
+				sc = sc->next;
+			}
+			st = st->next;
+		}
+		dbg ("while (st) %p end\n", st); //eric++
+	}
 
 }
